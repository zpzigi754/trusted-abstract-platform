module tap { 

type * = ap_types.*;
const * = ap_types.*;
function * = ap_types.*;
define * = ap_types.*;



//
// TAP uarch state
//
const block_os_ev_read  : boolean;

instance cpu : abstract_cpu();
instance see : see_cpu();



//
// State of the untrusted code (OS and its minion).
//
//the untrusted pages
var untrusted_addr_valid : addr_valid_t;
var untrusted_addr_map   : addr_map_t;
var untrusted_regs       : regs_t;
var untrusted_pc         : vaddr_t;


//
// The enclaves in the system
//
var tap_enclave_metadata_valid          : tap_enclave_metadata_valid_t;
var tap_enclave_metadata_addr_map       : tap_enclave_metadata_addr_map_t;
var tap_enclave_metadata_addr_valid     : tap_enclave_metadata_addr_valid_t;
var tap_enclave_metadata_addr_excl      : tap_enclave_metadata_addr_excl_t;
var tap_enclave_metadata_num_threads    : tap_enclave_metadata_num_threads_t;
var tap_enclave_metadata_entrypoint     : tap_enclave_metadata_entrypoint_t;
var tap_enclave_metadata_pc             : tap_enclave_metadata_pc_t;
var tap_enclave_metadata_regs           : tap_enclave_metadata_regs_t;
var tap_enclave_metadata_paused         : tap_enclave_metadata_paused_t;
var tap_enclave_metadata_cache_conflict : tap_enclave_metadata_cache_conflict_t;





//
// Helper Procedures
//
procedure [noinline] do_mappings_alias_v(
  addr_valid : excl_vaddr_t,
  addr_map   : addr_map_t
)
  returns (alias : boolean)
  ensures (exists (v1, v2 : vaddr_t) :: vaddr_alias(addr_valid, addr_map, v1, v2))
          <==> alias;
  ensures (forall (v1, v2 : vaddr_t) :: !vaddr_alias(addr_valid, addr_map, v1, v2))
          <==> (!alias);
{
  
}


procedure does_paddr_conflict(eid : tap_enclave_id_t, pa1 : wap_addr_t)
  returns (conflict : boolean)
  requires cpu.cpu_owner_map[pa1] == eid;
  ensures (exists (p : wap_addr_t) ::
                cpu.cpu_owner_map[p] != eid && paddr2set(pa1) == paddr2set(p))
          <==> conflict;
{
  var pa : wap_addr_t;

  pa = k0_wap_addr_t;
  conflict = false;
  while (LT_wapa(pa, kmax_wap_addr_t))
    invariant (exists (p : wap_addr_t) ::
                LT_wapa(p, pa) && cpu.cpu_owner_map[p] != eid && paddr2set(pa1) == paddr2set(p))
              <==> conflict;
  {
    if (cpu.cpu_owner_map[pa] != eid && paddr2set(pa1) == paddr2set(pa)) {
      conflict = true;
    }
    pa = PLUS_wapa(pa, k1_wap_addr_t);
  }
  if (cpu.cpu_owner_map[pa] != eid && paddr2set(pa1) == paddr2set(pa)) {
    conflict = true;
  }
}

procedure does_enclave_conflict(eid : tap_enclave_id_t)
  returns (conflict : boolean)
  ensures (exists (p1, p2 : wap_addr_t) ::
                cpu.cpu_owner_map[p1] == eid  &&
                cpu.cpu_owner_map[p2] != eid  &&
                paddr2set(p1) == paddr2set(p2))
            <==> conflict;
{
  var pa : wap_addr_t;
  var pa_conflict : boolean;

  pa = k0_wap_addr_t;
  conflict = false;
  while (LT_wapa(pa, kmax_wap_addr_t))
    invariant (exists (p1, p2 : wap_addr_t) ::
                  LT_wapa(p1, pa)           &&
                  cpu.cpu_owner_map[p1] == eid  &&
                  cpu.cpu_owner_map[p2] != eid  &&
                  paddr2set(p1) == paddr2set(p2))
              <==> conflict;
  {
    if (cpu.cpu_owner_map[pa] == eid) {
      call (pa_conflict) = does_paddr_conflict(eid, pa);
      conflict = conflict || pa_conflict;
    }
    pa = PLUS_wapa(pa, k1_wap_addr_t);
  }
  if (cpu.cpu_owner_map[pa] == eid) {
    call (pa_conflict) = does_paddr_conflict(eid, pa);
    conflict = conflict || pa_conflict;
  }
}




//
// CPU Procedures
//
procedure [noinline] initialize_tap()
  ensures cpu.cpu_enclave_id == tap_null_enc_id;
  ensures cpu.cpu_addr_map == untrusted_addr_map;
  ensures cpu.cpu_addr_valid == untrusted_addr_valid;
  ensures cpu.cpu_pc == untrusted_pc;
  ensures cpu.cpu_regs == untrusted_regs;
  ensures (forall (p : wap_addr_t) :: cpu.cpu_mem[p] == k0_word_t);
  ensures (forall (p : wap_addr_t) :: cpu.cpu_owner_map[p] == tap_null_enc_id);
  ensures (forall (e : tap_enclave_id_t) :: !tap_enclave_metadata_valid[e]);
  ensures (tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]));
  ensures cpu.cpu_cache_enabled ==>
            (forall (i : cache_set_index_t, w : cache_way_index_t) ::
              (valid_cache_set_index(i) && valid_cache_way_index(w)) ==> !cpu.cache.cache_valid_map[i, w]);
  ensures (forall (pa : wap_addr_t, e : tap_enclave_id_t) :: 
            (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
              (cpu.cpu_owner_map[pa] != e));
  ensures (forall (e : tap_enclave_id_t) ::
            tap_enclave_metadata_valid[e] ==>
              tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_entrypoint[e]]));
  modifies untrusted_addr_map,
           untrusted_addr_valid,
           untrusted_pc,
           untrusted_regs,
           tap_enclave_metadata_valid;
  modifies cpu;
{
  havoc untrusted_addr_map;
  havoc untrusted_addr_valid;
  havoc untrusted_addr_map; 
  havoc untrusted_pc;
  havoc untrusted_regs;
  
    
  call cpu.set_cpu_state(tap_null_enc_id,
                         untrusted_addr_map,
                         untrusted_addr_valid,
                         untrusted_pc,
                         untrusted_regs);
  


  // memory is all zero'd out
  call cpu.havoc_cpu_mem();
  assume (forall (p : wap_addr_t) :: cpu.cpu_mem[p] == k0_word_t);
  
  
  // no enclaves exists
  call cpu.havoc_cpu_owner_map();
  assume (forall (pa : wap_addr_t) :: cpu.cpu_owner_map[pa] == tap_null_enc_id);
  havoc tap_enclave_metadata_valid;
  assume (forall (e : tap_enclave_id_t) :: !tap_enclave_metadata_valid[e]);
  // and that the PC is in the same state
  assume (tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]));
  assume (cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == cpu.cpu_enclave_id);
  
  if (cpu.cpu_cache_enabled) {
    call cpu.initialize_cache();
  }
}


procedure [inline] set_addr_map(va : vaddr_t, pa : wap_addr_t, valid : addr_perm_t)
  //ensures (cpu.cpu_enclave_id == tap_null_enc_id ==> (untrusted_addr_valid[va] == valid &&
  //            cpu.cpu_addr_valid == untrusted_addr_valid));
  //ensures ((cpu.cpu_enclave_id == tap_null_enc_id && tap_addr_perm_v(valid)) ==>
  //            (untrusted_addr_map[va] == pa && cpu.cpu_addr_map == untrusted_addr_map));
  //ensures (cpu.cpu_enclave_id != tap_null_enc_id ==>
  //        cpu.cpu_addr_valid == old(cpu.cpu_addr_valid));

  modifies untrusted_addr_valid,
           untrusted_addr_map,
           cpu;
{
  if (cpu.cpu_enclave_id == tap_null_enc_id) {
    untrusted_addr_valid[va] = valid;
    call cpu.set_cpu_addr_valid(untrusted_addr_valid);
    if (tap_addr_perm_v(valid)) {
      untrusted_addr_map[va] = pa;
      call cpu.set_cpu_addr_map(untrusted_addr_map);
    }
  }
            
}

procedure [inline] get_enclave_addr_map(eid : tap_enclave_id_t, va  : vaddr_t)
    returns (valid : addr_perm_t, paddr: wap_addr_t)
    ensures (block_os_ev_read && (tap_enclave_metadata_addr_excl[eid])[va])
            ==> (valid == k0_addr_perm_t && paddr == k0_wap_addr_t);
    ensures (cpu.cpu_enclave_id != tap_null_enc_id || !tap_enclave_metadata_valid[eid])
            ==> (valid == k0_addr_perm_t && paddr == k0_wap_addr_t);
    ensures (cpu.cpu_enclave_id == tap_null_enc_id && tap_enclave_metadata_valid[eid] && (!block_os_ev_read || !((tap_enclave_metadata_addr_excl[eid])[va])))
            ==> (valid == (tap_enclave_metadata_addr_valid[eid])[va] &&
                 paddr == (tap_enclave_metadata_addr_map[eid])[va]);
{
  // default values
  valid = k0_addr_perm_t;
  paddr = k0_wap_addr_t;
  if (cpu.cpu_enclave_id == tap_null_enc_id   &&
      tap_enclave_metadata_valid[eid])
  {
    if (!block_os_ev_read || !((tap_enclave_metadata_addr_excl[eid])[va])) {
      valid = (tap_enclave_metadata_addr_valid[eid])[va];
      paddr = (tap_enclave_metadata_addr_map[eid])[va];
    }
  }
}

procedure [inline] set_enclave_addr_map(
  eid    : tap_enclave_id_t,
  va     : vaddr_t,
  valid  : addr_perm_t,
  paddr  : wap_addr_t
)
  returns (status : enclave_op_result_t)
  modifies tap_enclave_metadata_addr_valid;
  modifies tap_enclave_metadata_addr_map;
{
  // default values
  if (cpu.cpu_enclave_id == tap_null_enc_id &&
      tap_enclave_metadata_valid[eid])
  {
    if (!(tap_enclave_metadata_addr_excl[eid])[va]) {
      var valid_map : addr_valid_t;
      var addr_map  : addr_map_t;
      valid_map = tap_enclave_metadata_addr_valid[eid];
      addr_map  = tap_enclave_metadata_addr_map[eid];
      valid_map[va] = valid;
      addr_map[va]  = paddr;
      tap_enclave_metadata_addr_valid[eid] = valid_map;
      tap_enclave_metadata_addr_map[eid] = addr_map;
      status = enclave_op_success;
    } else {
      status = enclave_op_invalid_arg;
    } 
  } else {
    status = enclave_op_invalid_arg;
  }
}




//
// Helper definitions
//
define vaddr_alias(
  av       : excl_vaddr_t,
  am       : addr_map_t,
  va1, va2 : vaddr_t) : boolean
= (va1 != va2 && av[va1] && av[va2] && am[va1] == am[va2]);
  
  
//
// Launch and enclave
//
procedure [noinline] launch(
  eid               : tap_enclave_id_t,
  addr_valid        : addr_valid_t,
  addr_map          : addr_map_t,
  excl_vaddr        : excl_vaddr_t,
  excl_paddr        : excl_map_t,
  entrypoint        : vaddr_t
)
  returns (status : enclave_op_result_t)
  //
  // global TAP invariants
  //
  requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
              (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                  (cpu.cpu_owner_map[pa] != e));

    
  ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
              (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                  (cpu.cpu_owner_map[pa] != e));


  
   //these postconditions say that nothing change if status != success
  
  ensures (status != enclave_op_success ==> cpu.cpu_owner_map == old(cpu.cpu_owner_map));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_valid == old(tap_enclave_metadata_valid));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_excl == old(tap_enclave_metadata_addr_excl));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_entrypoint == old(tap_enclave_metadata_entrypoint));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
  ensures (status != enclave_op_success ==> tap_enclave_metadata_cache_conflict == old(tap_enclave_metadata_cache_conflict));

  
   //these postconditions say that only entry [eid] changes in the maps
  
  ensures (forall (pa : wap_addr_t) ::
            (status == enclave_op_success) ==>
              (excl_paddr[pa] <==> cpu.cpu_owner_map[pa] == eid));
  ensures (forall (pa : wap_addr_t) ::
            status == enclave_op_success ==> 
            (!excl_paddr[pa] ==> cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa]));
  ensures (forall (pa : wap_addr_t) ::
            status != enclave_op_success ==>
              (cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa]));
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==> 
              tap_enclave_metadata_valid[e] == old(tap_enclave_metadata_valid)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_addr_excl[e] == old(tap_enclave_metadata_addr_excl)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==> 
              tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_entrypoint[e] == old(tap_enclave_metadata_entrypoint)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_paused[e] == old(tap_enclave_metadata_paused)[e]);
  ensures (forall (e : tap_enclave_id_t) ::
            (e != eid) ==>
              tap_enclave_metadata_cache_conflict[e] == old(tap_enclave_metadata_cache_conflict)[e]);
    
   //conditions which specify when we fail.
  
  ensures
    ((cpu.cpu_enclave_id == tap_null_enc_id)                                                           &&
     (valid_enclave_id(eid))                                                                       &&
     (!old(tap_enclave_metadata_valid)[eid]) /* This */                                                      &&
     (tap_addr_perm_x(addr_valid[entrypoint]))                                                     &&
     (excl_paddr[addr_map[entrypoint]])                                                            &&
     (excl_vaddr[entrypoint])                                                                      &&
     (forall (pa : wap_addr_t) :: (excl_paddr[pa] ==> old(cpu.cpu_owner_map)[pa] == tap_null_enc_id))  && /* This line */
     (forall (v : vaddr_t) :: excl_vaddr[v] ==> tap_addr_perm_v(addr_valid[v]))                       &&
     (forall (v : vaddr_t) :: excl_vaddr[v] ==> excl_paddr[addr_map[v]])                              &&
     (forall (v1, v2 : vaddr_t) :: !vaddr_alias(excl_vaddr, addr_map, v1, v2))) 
  <==> (status == enclave_op_success);
  ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

  //ensures (status == enclave_op_success
  //          ==> valid_enclave_id(eid));

  
  //
  // specify what changes when we succeed
  //
  ensures (status == enclave_op_success ==> (forall (pa : wap_addr_t) ::
            (if (excl_paddr[pa]) then cpu.cpu_owner_map[pa] == eid
                               else cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa])));
  ensures (status == enclave_op_success) ==> (forall (pa : wap_addr_t) ::
            if (excl_paddr[pa]) then cpu.cpu_owner_map[pa] == eid
                              else cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa]);
  ensures (status == enclave_op_success) ==> (tap_enclave_metadata_valid[eid]);
  ensures (status == enclave_op_success) ==> (tap_enclave_metadata_pc[eid] == entrypoint);
  ensures (status == enclave_op_success) ==> (tap_enclave_metadata_entrypoint[eid] == entrypoint);
  ensures (status == enclave_op_success) ==> (!tap_enclave_metadata_paused[eid]);
  ensures (status == enclave_op_success) ==> (
            (exists (p1, p2 : wap_addr_t) :: cpu.cpu_owner_map[p1] == eid &&
                                             cpu.cpu_owner_map[p2] != eid &&
                                             paddr2set(p1) == paddr2set(p2)) 
            <==> tap_enclave_metadata_cache_conflict[eid]);
  ensures (status == enclave_op_success) ==>
            (tap_enclave_metadata_regs[eid] == kzero_regs_t);
  ensures (status == enclave_op_success) ==> 
            (tap_enclave_metadata_addr_valid[eid] == addr_valid);
  ensures (status == enclave_op_success) ==>
            (tap_enclave_metadata_addr_excl[eid] == excl_vaddr);
  ensures (status == enclave_op_success) ==>
            (tap_enclave_metadata_addr_map[eid] == addr_map);

  //// additional invariants that hold upon success
  ensures (status == enclave_op_success) ==>
            (forall (v1, v2 : vaddr_t) ::
              !vaddr_alias(tap_enclave_metadata_addr_excl[eid],
                           tap_enclave_metadata_addr_map[eid], v1, v2));
  ensures (status == enclave_op_success) ==>
            (forall (v : vaddr_t) ::
              (tap_enclave_metadata_addr_excl[eid])[v] ==>
              (cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[eid])[v]] == eid));
  ensures (status == enclave_op_success) ==>
            (forall (v : vaddr_t) ::
              (tap_enclave_metadata_addr_excl[eid])[v] ==>
              tap_addr_perm_v((tap_enclave_metadata_addr_valid[eid])[v]));
  modifies tap_enclave_metadata_valid;
  modifies tap_enclave_metadata_addr_map;
  modifies tap_enclave_metadata_addr_valid;
  modifies tap_enclave_metadata_addr_excl;
  modifies tap_enclave_metadata_entrypoint;
  modifies tap_enclave_metadata_pc;
  modifies tap_enclave_metadata_regs;
  modifies tap_enclave_metadata_paused;
  modifies tap_enclave_metadata_cache_conflict;
  modifies cpu;
{
  var i, k             : integer;
  var mappings_alias_v : boolean;
  var paddr            : wap_addr_t;
  var va               : vaddr_t;
  var cache_conflict   : boolean;

  status = enclave_op_success;
  
  // ensure cpu mode is valid
  if (cpu.cpu_enclave_id != tap_null_enc_id) { 
     status = enclave_op_invalid_arg; 
  }
  
  // ensure eid is valid
  if (status != enclave_op_invalid_arg && 
      (!valid_enclave_id(eid)           || 
      tap_enclave_metadata_valid[eid])) {
     status = enclave_op_invalid_arg; 
  }

  // the entrypoint must be mapped and exclusive
  if (status != enclave_op_invalid_arg         &&
      !tap_addr_perm_x(addr_valid[entrypoint]) ||
      !excl_paddr[addr_map[entrypoint]]        ||
      !excl_vaddr[entrypoint]) {
     status = enclave_op_invalid_arg; 
  }

  if (status != enclave_op_invalid_arg) {
    // ensure none of the paddrs are already exclusive
    paddr = k0_wap_addr_t;
    while (LT_wapa(paddr, kmax_wap_addr_t) && status != enclave_op_invalid_arg)
      //TODO: Verification techniques for while loop
      invariant ((status != enclave_op_invalid_arg) ==>
        (forall (pa : wap_addr_t) ::
          ((LT_wapa(pa, paddr) && excl_paddr[pa]) ==>
            cpu.cpu_owner_map[pa] == tap_null_enc_id)));
      invariant ((status != enclave_op_invalid_arg) ==>
        (forall (pa : wap_addr_t) ::
          (LT_wapa(pa, paddr) ==> cpu.cpu_owner_map[pa] != eid)));
    {
      if (excl_paddr[paddr]) {
        if (cpu.cpu_owner_map[paddr] != tap_null_enc_id) {
          status = enclave_op_invalid_arg;
        }
      }
      if (cpu.cpu_owner_map[paddr] == eid) {
        status = enclave_op_invalid_arg;
      }
      paddr = PLUS_wapa(paddr, k1_wap_addr_t);
    }
  }

  if (status != enclave_op_invalid_arg) {
    if ((excl_paddr[paddr] && cpu.cpu_owner_map[paddr] != tap_null_enc_id) ||
      (cpu.cpu_owner_map[paddr] == eid))
    {
      status = enclave_op_invalid_arg;
    } else {
      // check if the private addresses alias with anything else (paddr)
      call (mappings_alias_v) = do_mappings_alias_v(excl_vaddr, addr_map);
      if (mappings_alias_v) {
        status = enclave_op_invalid_arg;
      }
    }
  }
  
  if (status != enclave_op_invalid_arg) {

    // check if the private virt addresses map to a shared phys addr
    va = k0_vaddr_t;
    while (LT_va(va, kmax_vaddr_t) && status != enclave_op_invalid_arg)
      invariant ((status != enclave_op_invalid_arg) ==> 
                    (forall (v : vaddr_t) ::
                      (LT_va(v, va) && excl_vaddr[v]) ==> excl_paddr[addr_map[v]]));
      invariant ((status != enclave_op_invalid_arg) ==> 
                    (forall (v : vaddr_t) ::
                      (LT_va(v, va) && excl_vaddr[v]) ==> tap_addr_perm_v(addr_valid[v])));
    {
      if (excl_vaddr[va])
      {
        if (!excl_paddr[addr_map[va]] || !tap_addr_perm_v(addr_valid[va]))
        {
          status = enclave_op_invalid_arg;
        }
      }
      va = PLUS_va(va, k1_vaddr_t);
    }
    if (excl_vaddr[va] &&
       (!excl_paddr[addr_map[va]] || !tap_addr_perm_v(addr_valid[va])))
    {
      status = enclave_op_invalid_arg;
    }
  }


  if (status != enclave_op_invalid_arg) {

    // Set the CPU owner map.
    paddr = k0_wap_addr_t;
    while (LT_wapa(paddr, kmax_wap_addr_t))
      invariant (forall (pa : wap_addr_t) ::
                  (LT_wapa(pa, paddr) && excl_paddr[pa]) ==>
                    cpu.cpu_owner_map[pa] == eid);
      invariant (forall (pa : wap_addr_t) ::
                  (LT_wapa(pa, paddr) && !excl_paddr[pa]) ==>
                    cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa]);
      invariant (forall (pa : wap_addr_t) ::
                  !LT_wapa (pa, paddr) ==> cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa]);
      invariant (forall (e : tap_enclave_id_t, pa : wap_addr_t) ::
                  (e != eid && e != tap_null_enc_id) ==>
                    (cpu.cpu_owner_map[pa] == e) ==> (cpu.cpu_owner_map[pa] == old(cpu.cpu_owner_map)[pa]));
    {
      if (excl_paddr[paddr]) { call cpu.update_cpu_owner_map(paddr, eid); }
      paddr = PLUS_wapa(paddr, k1_wap_addr_t);
    }
    if (excl_paddr[paddr]) { call cpu.update_cpu_owner_map(paddr, eid); }
    
    // regs are zeroed out
    call (cache_conflict) = does_enclave_conflict(eid);
    
    tap_enclave_metadata_valid[eid]           = true;
    tap_enclave_metadata_addr_map[eid]        = addr_map;
    tap_enclave_metadata_addr_valid[eid]      = addr_valid;
    tap_enclave_metadata_addr_excl[eid]       = excl_vaddr;
    tap_enclave_metadata_entrypoint[eid]      = entrypoint;
    tap_enclave_metadata_pc[eid]              = entrypoint;
    tap_enclave_metadata_regs[eid]            = kzero_regs_t;
    tap_enclave_metadata_paused[eid]          = false;
    tap_enclave_metadata_cache_conflict[eid]  = cache_conflict;
    status = enclave_op_success;
  }
}

procedure [noinline] simple_test()
    ensures (see.enclave_id != old(see.enclave_id));
    modifies see;
{
    call see.havoc_enclave_id();
}
  
//
// enter an enclave
//
procedure [noinline] enter(eid: tap_enclave_id_t)
    returns (status : enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));

    //----------------------------------------------------------------------//
    // conditions for success or failure.                                   //
    //----------------------------------------------------------------------//
    ensures ((valid_enclave_id(eid))                   &&
             (tap_enclave_metadata_valid[eid])         &&
             (old(cpu.cpu_enclave_id) == tap_null_enc_id)) ==> (status == enclave_op_success);
    ensures ((!valid_enclave_id(eid))                  ||
             (!tap_enclave_metadata_valid[eid])        ||
             (old(cpu.cpu_enclave_id) != tap_null_enc_id)) ==> (status == enclave_op_invalid_arg);
    ensures (status == enclave_op_success || status == enclave_op_invalid_arg);
                
    //----------------------------------------------------------------------//
    // nothing changes on failure.                                          //
    //----------------------------------------------------------------------//
    ensures (status != enclave_op_success ==> cpu.cpu_enclave_id == old(cpu.cpu_enclave_id));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_valid == old(cpu.cpu_addr_valid));
    ensures (status != enclave_op_success ==> (cpu.cpu_addr_map == old(cpu.cpu_addr_map)));
    ensures (status != enclave_op_success ==> cpu.cpu_pc == old(cpu.cpu_pc));
    ensures (status != enclave_op_success ==> untrusted_regs == old(untrusted_regs));
    ensures (status != enclave_op_success ==> untrusted_addr_valid == old(untrusted_addr_valid));
    ensures (status != enclave_op_success ==> untrusted_addr_map == old(untrusted_addr_map));
    ensures (status != enclave_op_success ==> untrusted_pc == old(untrusted_pc));

    //----------------------------------------------------------------------//
    // state updates on success.                                            //
    //----------------------------------------------------------------------//
    ensures (status == enclave_op_success) ==> (untrusted_pc == old(cpu.cpu_pc));
    ensures (status == enclave_op_success) ==> (cpu.cpu_enclave_id == eid);
    ensures (status == enclave_op_success) ==> (cpu.cpu_pc == tap_enclave_metadata_entrypoint[eid]);
    ensures (status == enclave_op_success) ==> (untrusted_regs == old(cpu.cpu_regs));
    ensures (status == enclave_op_success) ==> (untrusted_addr_valid == old(cpu.cpu_addr_valid));
    ensures (status == enclave_op_success) ==> (untrusted_addr_map == old(cpu.cpu_addr_map));
    ensures (status == enclave_op_success) ==> (cpu.cpu_addr_valid == tap_enclave_metadata_addr_valid[eid]);
    ensures (status == enclave_op_success) ==> (cpu.cpu_addr_map == tap_enclave_metadata_addr_map[eid]);
    ensures (tap_addr_perm_x(old(cpu.cpu_addr_valid)[old(cpu.cpu_pc)])
              ==> (status == enclave_op_success
                    ==> tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])));    
    ensures (cpu.cpu_regs == old(cpu.cpu_regs));


    modifies untrusted_regs;
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_pc;
    modifies cpu;
{
    // no enclave id is null
    // enclave must be valid and not baused
    // cpu must be ready to execute enclaves
    if (!valid_enclave_id(eid)              ||
        !tap_enclave_metadata_valid[eid]    ||
        cpu.cpu_enclave_id != tap_null_enc_id)
    {
      status = enclave_op_invalid_arg;
    } else {
      status                  = enclave_op_success;
      // save context
      untrusted_regs          = cpu.cpu_regs;
      untrusted_addr_valid    = cpu.cpu_addr_valid;
      untrusted_addr_map      = cpu.cpu_addr_map;
      untrusted_pc            = cpu.cpu_pc;
      // restore enclave context
      call cpu.set_cpu_state(eid,
                             tap_enclave_metadata_addr_map[eid],
                             tap_enclave_metadata_addr_valid[eid],
                             tap_enclave_metadata_entrypoint[eid],
                             cpu.cpu_regs);
    }
}


//
// Resume an enclave
//
procedure [noinline]  resume(eid: tap_enclave_id_t)
    returns (status : enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));

    //----------------------------------------------------------------------//
    // conditions for success or failure.                                   //
    //----------------------------------------------------------------------//
    ensures ((valid_enclave_id(eid))                      &&
             (tap_enclave_metadata_valid[eid])            && 
             (tap_enclave_metadata_paused[eid])           &&
             (old(cpu.cpu_enclave_id) == tap_null_enc_id))    ==> (status == enclave_op_success);
    ensures ((!valid_enclave_id(eid))                     ||
             (!tap_enclave_metadata_valid[eid])           || 
             (!tap_enclave_metadata_paused[eid])          ||
             (old(cpu.cpu_enclave_id) != tap_null_enc_id))    ==> (status == enclave_op_invalid_arg);
    ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

    //----------------------------------------------------------------------//
    // nothing changes on failure.                                          //
    //----------------------------------------------------------------------//
    ensures (status != enclave_op_success ==> cpu.cpu_regs == old(cpu.cpu_regs));
    ensures (status != enclave_op_success ==> cpu.cpu_enclave_id == old(cpu.cpu_enclave_id));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_valid == old(cpu.cpu_addr_valid));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_map == old(cpu.cpu_addr_map));
    ensures (status != enclave_op_success ==> cpu.cpu_pc == old(cpu.cpu_pc));
    ensures (status != enclave_op_success ==> untrusted_regs == old(untrusted_regs));
    ensures (status != enclave_op_success ==> untrusted_addr_valid == old(untrusted_addr_valid));
    ensures (status != enclave_op_success ==> untrusted_addr_map == old(untrusted_addr_map));
    ensures (status != enclave_op_success ==> untrusted_pc == old(untrusted_pc));

    //----------------------------------------------------------------------//
    // state updates on success.                                            //
    //----------------------------------------------------------------------//
    ensures (status == enclave_op_success) ==> (untrusted_pc == old(cpu.cpu_pc));
    ensures (status == enclave_op_success) ==> (cpu.cpu_enclave_id == eid);
    ensures (status == enclave_op_success) ==> (cpu.cpu_pc == tap_enclave_metadata_pc[eid]);
    ensures (status == enclave_op_success) ==> (untrusted_regs == old(cpu.cpu_regs));
    ensures (status == enclave_op_success) ==> (untrusted_addr_valid == old(cpu.cpu_addr_valid));
    ensures (status == enclave_op_success) ==> (untrusted_addr_map == old(cpu.cpu_addr_map));
    ensures (status == enclave_op_success) ==> (cpu.cpu_regs == tap_enclave_metadata_regs[eid]);
    ensures (status == enclave_op_success) ==> (cpu.cpu_addr_valid == tap_enclave_metadata_addr_valid[eid]);
    ensures (status == enclave_op_success) ==> (cpu.cpu_addr_map == tap_enclave_metadata_addr_map[eid]);
    ensures (tap_addr_perm_x(old(cpu.cpu_addr_valid)[old(cpu.cpu_pc)])
              ==> (status == enclave_op_success
                    ==> tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])));

    modifies untrusted_regs;
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_pc;
    modifies cpu;
{
  if (!valid_enclave_id(eid)              ||
      !tap_enclave_metadata_valid[eid]    ||
      !tap_enclave_metadata_paused[eid]   ||
      cpu.cpu_enclave_id != tap_null_enc_id) 
  {
    status = enclave_op_invalid_arg;
  } else {
    // save context
    untrusted_regs                = cpu.cpu_regs;
    untrusted_addr_valid          = cpu.cpu_addr_valid;
    untrusted_addr_map            = cpu.cpu_addr_map;
    untrusted_pc                  = cpu.cpu_pc;
    // restore enclave context
    call cpu.set_cpu_state(eid,
                           tap_enclave_metadata_addr_map[eid],
                           tap_enclave_metadata_addr_valid[eid],
                           tap_enclave_metadata_pc[eid],
                           tap_enclave_metadata_regs[eid]);
    status = enclave_op_success;
  }
}


// -------------------------------------------------------------------- //
// Exit an enclave.                                                     //
// -------------------------------------------------------------------- //
procedure [noinline]  exit()
    returns (status : enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
               
    //----------------------------------------------------------------------//
    // success/failure conditions.                                          //
    //----------------------------------------------------------------------//
    ensures (old(cpu.cpu_enclave_id) == tap_null_enc_id) ==> (status == enclave_op_failed);
    ensures (old(cpu.cpu_enclave_id) != tap_null_enc_id) ==> (status == enclave_op_success);
    ensures (status == enclave_op_success || status == enclave_op_failed);

    //----------------------------------------------------------------------//
    // nothing changes on failure.                                          //
    //----------------------------------------------------------------------//
    ensures (status != enclave_op_success ==> cpu.cpu_regs == old(cpu.cpu_regs));
    ensures (status != enclave_op_success ==> cpu.cpu_enclave_id == old(cpu.cpu_enclave_id));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_valid == old(cpu.cpu_addr_valid));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_map == old(cpu.cpu_addr_map));
    ensures (status != enclave_op_success ==> cpu.cpu_pc == old(cpu.cpu_pc));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
    // nothing except eid changes for paused, pc, addr_valid and addr_map
    ensures (forall (e : tap_enclave_id_t) :: 
        e != old(cpu.cpu_enclave_id) ==> 
            (tap_enclave_metadata_paused[e] == old(tap_enclave_metadata_paused)[e]));
    ensures (forall (e : tap_enclave_id_t) :: 
        e != old(cpu.cpu_enclave_id) ==> 
            (tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]));
    ensures (forall (e : tap_enclave_id_t) ::
        e != old(cpu.cpu_enclave_id) ==>
            tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
        e != old(cpu.cpu_enclave_id) ==>
            tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);

    //----------------------------------------------------------------------//
    // state updates on success.                                            //
    //----------------------------------------------------------------------//
    ensures (status == enclave_op_success) ==> (cpu.cpu_pc == old(untrusted_pc));
    ensures (status == enclave_op_success) ==> (cpu.cpu_enclave_id == tap_null_enc_id);
    ensures (status == enclave_op_success) ==> (!tap_enclave_metadata_paused[old(cpu.cpu_enclave_id)]);
    ensures (status == enclave_op_success) ==> 
            (tap_enclave_metadata_pc[old(cpu.cpu_enclave_id)] == tap_enclave_metadata_entrypoint[old(cpu.cpu_enclave_id)]);
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_addr_valid[old(cpu.cpu_enclave_id)] == old(cpu.cpu_addr_valid));
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_addr_map[old(cpu.cpu_enclave_id)] == old(cpu.cpu_addr_map));
    ensures (status == enclave_op_success) ==> (cpu.cpu_regs == untrusted_regs);
    ensures (status == enclave_op_success) ==> (cpu.cpu_addr_valid == untrusted_addr_valid);
    ensures (status == enclave_op_success) ==> (cpu.cpu_addr_map == untrusted_addr_map);
    ensures (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])
              ==> (status == enclave_op_success 
                    ==> tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc])));
    ensures (status == enclave_op_success
              ==> (cpu.cpu_owner_map[untrusted_addr_map[untrusted_pc]]
                    == cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]]));



    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_paused;
    modifies cpu;
{
  var eid : tap_enclave_id_t;
  
  if (cpu.cpu_enclave_id == tap_null_enc_id) {
    status = enclave_op_failed;
  } else {
    status = enclave_op_success;

    eid                                   = cpu.cpu_enclave_id;
    tap_enclave_metadata_addr_valid[eid]  = cpu.cpu_addr_valid;
    tap_enclave_metadata_addr_map[eid]    = cpu.cpu_addr_map;
    tap_enclave_metadata_pc[eid]          = tap_enclave_metadata_entrypoint[eid];
    tap_enclave_metadata_paused[eid]      = false;
    
    call cpu.set_cpu_state(tap_null_enc_id,
                           untrusted_addr_map,
                           untrusted_addr_valid,
                           untrusted_pc,
                           untrusted_regs);
    status = enclave_op_success;
  }
}


//
// Pause an enclave
//
procedure [noinline]  pause()
    returns (status : enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    //----------------------------------------------------------------------//
    // success/failure conditions.                                          //
    //----------------------------------------------------------------------//
    ensures (old(cpu.cpu_enclave_id) == tap_null_enc_id) ==> (status == enclave_op_failed);
    ensures (old(cpu.cpu_enclave_id) != tap_null_enc_id) ==> (status == enclave_op_success);
    ensures (status == enclave_op_success || status == enclave_op_failed);
               
    //----------------------------------------------------------------------//
    // nothing changes on failure.                                          //
    //----------------------------------------------------------------------//
    ensures (status != enclave_op_success ==> cpu.cpu_regs == old(cpu.cpu_regs));
    ensures (status != enclave_op_success ==> cpu.cpu_enclave_id == old(cpu.cpu_enclave_id));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_valid == old(cpu.cpu_addr_valid));
    ensures (status != enclave_op_success ==> cpu.cpu_addr_map == old(cpu.cpu_addr_map));
    ensures (status != enclave_op_success ==> cpu.cpu_pc == old(cpu.cpu_pc));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
    // nothing except eid changes for paused, pc, regs, addr_valid and addr_map
    ensures (forall (e : tap_enclave_id_t) :: 
        e != old(cpu.cpu_enclave_id) ==> 
            (tap_enclave_metadata_paused[e] == old(tap_enclave_metadata_paused)[e]));
    ensures (forall (e : tap_enclave_id_t) :: 
        e != old(cpu.cpu_enclave_id) ==> 
            (tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]));
    ensures (forall (e : tap_enclave_id_t) ::
        e != old(cpu.cpu_enclave_id) ==>
            tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
        e != old(cpu.cpu_enclave_id) ==>
            tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
        e != old(cpu.cpu_enclave_id) ==>
            tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);

    //----------------------------------------------------------------------//
    // state updates on success.                                            //
    //----------------------------------------------------------------------//
    ensures (status == enclave_op_success) ==> (cpu.cpu_pc == old(untrusted_pc));
    ensures (status == enclave_op_success) ==> (cpu.cpu_enclave_id == tap_null_enc_id);
    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_paused[old(cpu.cpu_enclave_id)]);
    ensures (status == enclave_op_success) ==> 
            (tap_enclave_metadata_pc[old(cpu.cpu_enclave_id)] == old(cpu.cpu_pc));
    ensures (status == enclave_op_success) ==>
            (tap_enclave_metadata_regs[old(cpu.cpu_enclave_id)] == old(cpu.cpu_regs));
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_addr_valid[old(cpu.cpu_enclave_id)] == old(cpu.cpu_addr_valid));
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_addr_map[old(cpu.cpu_enclave_id)] == old(cpu.cpu_addr_map));
    ensures (status == enclave_op_success) ==>
            (cpu.cpu_regs == untrusted_regs);
    ensures (status == enclave_op_success) ==>
            (cpu.cpu_addr_valid == untrusted_addr_valid);
    ensures (status == enclave_op_success) ==>
            (cpu.cpu_addr_map == untrusted_addr_map);
    ensures (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])
              ==> (status == enclave_op_success 
                    ==> tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc])));
    ensures (status == enclave_op_success
              ==> (cpu.cpu_owner_map[untrusted_addr_map[untrusted_pc]]
                    == cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]]));

    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_paused;
    modifies cpu;

{
  var eid : tap_enclave_id_t;
    
  if (cpu.cpu_enclave_id == tap_null_enc_id) {
    status = enclave_op_failed;
  } else {

    eid                                  = cpu.cpu_enclave_id;
    tap_enclave_metadata_regs[eid]       = cpu.cpu_regs;
    tap_enclave_metadata_addr_valid[eid] = cpu.cpu_addr_valid;
    tap_enclave_metadata_addr_map[eid]   = cpu.cpu_addr_map;
    tap_enclave_metadata_pc[eid]         = cpu.cpu_pc;
    tap_enclave_metadata_paused[eid]     = true;

    call cpu.set_cpu_state(tap_null_enc_id,
                           untrusted_addr_map,
                           untrusted_addr_valid,
                           untrusted_pc,
                           untrusted_regs);
    status = enclave_op_success;
  }
}


//
// Destroy an enclave
//
procedure [noinline]  destroy(eid: tap_enclave_id_t)
    returns (status: enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));

    //----------------------------------------------------------------------//
    // success/failure conditions.                                          //
    //----------------------------------------------------------------------//
    ensures (!valid_enclave_id(eid)                 || 
             !old(tap_enclave_metadata_valid)[eid]  || 
             cpu.cpu_enclave_id != tap_null_enc_id) ==> (status == enclave_op_invalid_arg);
    ensures (valid_enclave_id(eid)                  && 
             old(tap_enclave_metadata_valid)[eid]   && 
             cpu.cpu_enclave_id == tap_null_enc_id) ==> (status == enclave_op_success);
    ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

    //----------------------------------------------------------------------//
    // nothing changes on failure.                                          //
    //----------------------------------------------------------------------//
    ensures (status != enclave_op_success ==> cpu.cpu_owner_map == old(cpu.cpu_owner_map));
    ensures (status != enclave_op_success ==> cpu.cpu_pc == old(cpu.cpu_pc));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_valid == old(tap_enclave_metadata_valid));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
    // regs don't change except for eid.
    ensures (forall (e : tap_enclave_id_t) ::
                (e != eid) ==> tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);

    //----------------------------------------------------------------------//
    // status updates on success                                            //
    //----------------------------------------------------------------------//
    ensures (status == enclave_op_success) ==>
                (forall (p : wap_addr_t) ::
                    (if (old(cpu.cpu_owner_map)[p] == eid)
                        then (cpu.cpu_owner_map[p] == tap_blocked_enc_id)
                        else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p])));
    ensures (status == enclave_op_success) ==>
                (forall (p : wap_addr_t) ::
                    old(cpu.cpu_owner_map)[p] == eid ==>
                        (cpu.cpu_owner_map[p] == tap_blocked_enc_id));
    ensures (status == enclave_op_success) ==>
                (forall (p : wap_addr_t) ::
                    old(cpu.cpu_owner_map)[p] != eid ==> 
                        cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p]);
    ensures (status == enclave_op_success) ==>
                (forall (e : tap_enclave_id_t) :: 
                    tap_enclave_metadata_valid[e] == 
                        (if (e == eid) then false
                                     else old(tap_enclave_metadata_valid)[e]));
    ensures (status == enclave_op_success) ==>
                (forall (e : tap_enclave_id_t) :: 
                    tap_enclave_metadata_pc[e] == 
                        (if (e == eid) then k0_vaddr_t
                                     else old(tap_enclave_metadata_pc)[e]));
    ensures (status == enclave_op_success) ==>
                (tap_enclave_metadata_regs[eid] == kzero_regs_t);

    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_pc;
    modifies cpu;
{
  var va : wap_addr_t;
  var pa : wap_addr_t;
  // no enclave_id is null
  if (!valid_enclave_id(eid) || !tap_enclave_metadata_valid[eid] || cpu.cpu_enclave_id != tap_null_enc_id) {
    status = enclave_op_invalid_arg;
  } else {

    assert (cpu.cpu_enclave_id != eid);
    assert tap_enclave_metadata_valid[eid];

    // we have to clear out the enclave's registers and memory.
    pa = k0_wap_addr_t;
    while (LT_wapa(pa, kmax_wap_addr_t))
      invariant (forall (p : wap_addr_t) ::
                  LT_wapa(p, pa) ==>
                    (if (old(cpu.cpu_owner_map)[p] == eid)
                        then (cpu.cpu_owner_map[p] == tap_blocked_enc_id)
                        else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p])));
      invariant (forall (p : wap_addr_t) ::
                  (!LT_wapa(p, pa) ==> 
                    (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p])));
    {
      if (cpu.cpu_owner_map[pa] == eid) {
        call cpu.update_cpu_owner_map(pa, tap_blocked_enc_id);
      }
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }
    if (cpu.cpu_owner_map[kmax_wap_addr_t] == eid) {
      call cpu.update_cpu_owner_map(kmax_wap_addr_t, tap_blocked_enc_id);
    }
    assert (forall (p : wap_addr_t) ::
              (if (old(cpu.cpu_owner_map)[p] == eid)
                  then (cpu.cpu_owner_map[p] == tap_blocked_enc_id)
                  else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p])));
    assert (forall (p : wap_addr_t) ::
              (old(cpu.cpu_owner_map)[p] == eid) ==> 
                (cpu.cpu_owner_map[p] == tap_blocked_enc_id));
    assert (forall (p : wap_addr_t) ::
              (old(cpu.cpu_owner_map)[p] != eid) ==>
                (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p]));
    assert (forall (p : wap_addr_t) ::
              (old(cpu.cpu_owner_map)[p] != eid) ==> cpu.cpu_mem[p] == old(cpu.cpu_mem)[p]);

    // and now we mark the enclave invalid
    tap_enclave_metadata_valid[eid] = false;
    tap_enclave_metadata_regs[eid]  = kzero_regs_t;
    tap_enclave_metadata_pc[eid]    = k0_vaddr_t;
    
    status = enclave_op_success;
  }
}


//
// Block available memory
//
procedure [noinline] block_memory_region(bmap : excl_map_t)
   returns (status : enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));

    // success condition.
    ensures ((forall (p : wap_addr_t) ::
                bmap[p] ==> (old(cpu.cpu_owner_map)[p] == tap_null_enc_id))
            <==> (status == enclave_op_success));
    ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

    // effect on cpu.cpu_owner_map
    ensures (status == enclave_op_success) ==>
            (forall (p : wap_addr_t) :: 
                if (bmap[p]) 
                    then cpu.cpu_owner_map[p] == tap_blocked_enc_id
                    else cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p]);
    ensures (status != enclave_op_success) ==> 
                old(cpu.cpu_owner_map) == cpu.cpu_owner_map;

    modifies cpu;
{
  var pa : wap_addr_t;
  // First make sure that all the addresses in bmap are blocked
  pa = k0_wap_addr_t;

  //Ensures that we dont simply terminate initially
  status = enclave_op_success;

  while (LT_wapa(pa, kmax_wap_addr_t) && status != enclave_op_invalid_arg)
    invariant ((status != enclave_op_invalid_arg) ==> 
                (forall (p : wap_addr_t) ::
                  (LT_wapa(p, pa) && bmap[p]) ==> (cpu.cpu_owner_map[p] == tap_null_enc_id)));
  {
    if (bmap[pa] && (cpu.cpu_owner_map[pa] != tap_null_enc_id)) {
      status = enclave_op_invalid_arg;
    }
    
    pa = PLUS_wapa(pa, k1_wap_addr_t);
  }

  
  if ((status != enclave_op_invalid_arg) && bmap[pa] && (cpu.cpu_owner_map[pa] != tap_null_enc_id)) {
      status = enclave_op_invalid_arg;
  }
  
  if (status != enclave_op_invalid_arg) {
    assert (forall (p : wap_addr_t) :: bmap[p] ==> (cpu.cpu_owner_map[p] == tap_null_enc_id));

    // NOw go around clearing each address in bmap
    pa = k0_wap_addr_t;
    while (LT_wapa(pa, kmax_wap_addr_t))
      invariant (forall (p : wap_addr_t) :: bmap[p] ==>
                  (if (LT_wapa(p, pa))
                       then cpu.cpu_owner_map[p] == tap_blocked_enc_id
                       else cpu.cpu_owner_map[p] == tap_null_enc_id));
      invariant (forall (p : wap_addr_t) ::
                  (if (LT_wapa(p, pa) && bmap[p])
                       then cpu.cpu_owner_map[p] == tap_blocked_enc_id
                       else cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p]));
    {
      if (bmap[pa]) {
        call cpu.update_cpu_owner_map(pa, tap_blocked_enc_id);
      }
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }
    if (bmap[pa]) {
      call cpu.update_cpu_owner_map(pa, tap_blocked_enc_id);
    }
    assert (forall (p : wap_addr_t) ::
            if (bmap[p])
               then (cpu.cpu_owner_map[p] == tap_blocked_enc_id)
               else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p]));
    status = enclave_op_success;
  }
}


//
// Reclaim blocked memory
//
procedure [noinline] release_blocked_memory(bmap : excl_map_t)
    returns (status : enclave_op_result_t)

    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));

    // success condition.
    ensures ((forall (p : wap_addr_t) ::
                bmap[p] ==> (old(cpu.cpu_owner_map)[p] == tap_blocked_enc_id))
            <==> (status == enclave_op_success));
    ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

    // effect on cpu.cpu_owner_map
    ensures (status == enclave_op_success) ==>
            (forall (p : wap_addr_t) :: 
                if (bmap[p])
                    then (cpu.cpu_owner_map[p] == tap_null_enc_id && 
                          cpu.cpu_mem[p] == k0_word_t)
                    else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p] && 
                          cpu.cpu_mem[p] == old(cpu.cpu_mem)[p]));
    ensures (status != enclave_op_success) ==> 
                (old(cpu.cpu_owner_map) == cpu.cpu_owner_map &&
                 old(cpu.cpu_mem) == cpu.cpu_mem);

    modifies cpu;
{
  var pa : wap_addr_t;
  // First make sure that all the addresses in bmap are blocked
  pa = k0_wap_addr_t;

  //Ensures that we dont simply terminate initially
  status = enclave_op_success;


  while (LT_wapa(pa, kmax_wap_addr_t) && status != enclave_op_invalid_arg)
    invariant ((status != enclave_op_invalid_arg) ==>
                  (forall (p : wap_addr_t) ::
                    (LT_wapa(p, pa) && bmap[p]) ==> (cpu.cpu_owner_map[p] == tap_blocked_enc_id)));
  
  {
    if (bmap[pa] && cpu.cpu_owner_map[pa] != tap_blocked_enc_id) {
      status = enclave_op_invalid_arg;
    }
    pa = PLUS_wapa(pa, k1_wap_addr_t);
  }
  if (status != enclave_op_invalid_arg && bmap[pa] && cpu.cpu_owner_map[pa] != tap_blocked_enc_id) {
    status = enclave_op_invalid_arg;
  }

  if (status != enclave_op_invalid_arg) {
    assert (forall (p : wap_addr_t) :: bmap[p] ==> (cpu.cpu_owner_map[p] == tap_blocked_enc_id));

    // Now go around clearing each address in bmap
    pa = k0_wap_addr_t;
    while (LT_wapa(pa, kmax_wap_addr_t))
      invariant (forall (p : wap_addr_t) :: bmap[p] ==>
                  (if (LT_wapa(p, pa))
                      then cpu.cpu_owner_map[p] == tap_null_enc_id
                      else cpu.cpu_owner_map[p] == tap_blocked_enc_id));
      invariant (forall (p : wap_addr_t) ::
                  if (LT_wapa(p, pa) && bmap[p])
                      then (cpu.cpu_owner_map[p] == tap_null_enc_id && cpu.cpu_mem[p] == k0_word_t)
                      else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p] && cpu.cpu_mem[p] == old(cpu.cpu_mem)[p]));
    {
      if (bmap[pa]) {
        call cpu.update_cpu_owner_map(pa, tap_null_enc_id);
        call cpu.update_cpu_mem(pa, k0_word_t);
      }
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }
    if (bmap[pa]) {
      call cpu.update_cpu_owner_map(pa, tap_null_enc_id);
      call cpu.update_cpu_mem(pa, k0_word_t);

    }
    assert (forall (p : wap_addr_t) ::
              if (bmap[p])
                 then (cpu.cpu_owner_map[p] == tap_null_enc_id && cpu.cpu_mem[p] == k0_word_t)
                 else (cpu.cpu_owner_map[p] == old(cpu.cpu_owner_map)[p] && cpu.cpu_mem[p] == old(cpu.cpu_mem)[p]));
    status = enclave_op_success;
  }
}

//
// Proof support
// 


//
// For refinement proof
//

procedure  [inline] cpu_fetch_va(vaddr : vaddr_t, repl_way : cache_way_index_t) 
    returns (data : word_t, excp : exception_t, hit : boolean)
    modifies cpu;
{
    call (data, excp, hit) = cpu.fetch_va(vaddr, repl_way);
}

procedure [inline] cpu_load_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
    returns (data : word_t, excp : exception_t, hit : boolean)
    modifies cpu;
{
    call (data, excp, hit) = cpu.load_va(vaddr, repl_way);
}


procedure [inline] cpu_store_va(vaddr : vaddr_t, data : word_t, repl_way : cache_way_index_t)
    returns (excp : exception_t, hit : boolean)
    modifies cpu;
{
    call (excp, hit) = cpu.store_va(vaddr, data, repl_way);
}


//
// Common Procedures found in ImplCommon.bpl
//
procedure [inline] tap_addr_valid_proofs()
{
    // setting the present bit does not affect the axrw bits.
    assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_p(p)));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_p(p)) == tap_addr_perm_a(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_p(p)) == tap_addr_perm_x(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_p(p)) == tap_addr_perm_r(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_p(p)) == tap_addr_perm_w(p));
    // setting the a bit does not affect the pxrw bits.
    assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_a(p)));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_a(p)) == tap_addr_perm_p(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_a(p)) == tap_addr_perm_x(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_a(p)) == tap_addr_perm_r(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_a(p)) == tap_addr_perm_w(p));
    // setting the x bit does not affect parw.
    assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_x(p)));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_x(p)) == tap_addr_perm_p(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_x(p)) == tap_addr_perm_a(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_x(p)) == tap_addr_perm_r(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_x(p)) == tap_addr_perm_w(p));
    // setting the r bit does not affect paxw.
    assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_r(p)));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_r(p)) == tap_addr_perm_p(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_x(p)) == tap_addr_perm_a(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_r(p)) == tap_addr_perm_x(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_r(p)) == tap_addr_perm_w(p));
    // setting the w bit does not affect pax:.
    assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_w(p)));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_w(p)) == tap_addr_perm_p(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_x(p)) == tap_addr_perm_a(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_w(p)) == tap_addr_perm_x(p));
    assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_w(p)) == tap_addr_perm_r(p));
    // tap_addr_perm_eq
    assert (forall (p1, p2 : addr_perm_t) :: (tap_addr_perm_eq(p1, p2)) <==>
                                           (tap_addr_perm_bits(p1) == tap_addr_perm_bits(p2)));
}

procedure [noinline] InitialHavoc()
    returns (current_mode : mode_t)
    ensures (current_mode == mode_untrusted);
    //----------------------------------------------------------------------//
    // global TAP invariants.                                               //
    //----------------------------------------------------------------------//
    ensures (cpu.cpu_enclave_id == tap_null_enc_id);
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                    (cpu.cpu_owner_map[pa] != e));
    // current pc invariants
    ensures (tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]));
    ensures (cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == cpu.cpu_enclave_id);
    // enclave invariants.
    ensures (forall (e : tap_enclave_id_t) :: !valid_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
    ensures (forall (e : tap_enclave_id_t) ::
                tap_enclave_metadata_valid[e] ==> 
                    tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_pc[e]]));
    ensures (forall (e : tap_enclave_id_t) ::
                tap_enclave_metadata_valid[e] ==> 
                    tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_entrypoint[e]]));
    ensures (forall (e : tap_enclave_id_t) ::
                tap_enclave_metadata_valid[e] ==> 
                    (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_pc[e]]);
    ensures (forall (e : tap_enclave_id_t) ::
                tap_enclave_metadata_valid[e] ==> 
                    (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_entrypoint[e]]);
    ensures (forall (e : tap_enclave_id_t) ::
                tap_enclave_metadata_valid[e] ==> 
                    cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_pc[e]]] == e);
    ensures (forall (e : tap_enclave_id_t) ::
                tap_enclave_metadata_valid[e] ==> 
                    cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_entrypoint[e]]] == e);
    // CPU/Enclave address map invariants.
    ensures (forall (va : vaddr_t) :: 
                (cpu.cpu_enclave_id == tap_null_enc_id) ==> 
                    (cpu.cpu_addr_map[va] == untrusted_addr_map[va]));
    ensures (forall (va : vaddr_t) :: 
                (cpu.cpu_enclave_id == tap_null_enc_id) ==> 
                    tap_addr_perm_eq(cpu.cpu_addr_valid[va], untrusted_addr_valid[va]));
    ensures (forall (va : vaddr_t) :: 
                (cpu.cpu_enclave_id != tap_null_enc_id) ==> 
                    (cpu.cpu_addr_map[va] == (tap_enclave_metadata_addr_map[cpu.cpu_enclave_id])[va]));
    ensures (forall (va : vaddr_t) :: 
                (cpu.cpu_enclave_id != tap_null_enc_id) ==> 
                    tap_addr_perm_eq(cpu.cpu_addr_valid[va], (tap_enclave_metadata_addr_valid[cpu.cpu_enclave_id])[va]));
    modifies cpu;
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_regs;
    modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_excl;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
{
    var status            : enclave_op_result_t;
    var r_eid             : tap_enclave_id_t;
    var r_addr_valid      : addr_valid_t;
    var r_addr_map        : addr_map_t;
    var r_addr_excl       : excl_vaddr_t;
    var r_excl_map        : excl_map_t;
    var r_container_valid : container_valid_t;
    var r_container_data  : container_data_t;
    var r_entrypoint      : vaddr_t;
    var r_vaddr           : vaddr_t;
    var r_paddr           : wap_addr_t;
    var r_word            : word_t;
    var r_valid           : addr_perm_t;
    var r_excp            : exception_t;
    var repl_way          : cache_way_index_t;
    var done              : boolean;
    var hit               : boolean;

    
    call initialize_tap();
    current_mode = mode_untrusted;
    // and loop will run for a few iterations.
    done = false;



    while (!done)
        // CPU invariants.
        invariant (done ==> (cpu.cpu_enclave_id == tap_null_enc_id));
        // current pc invariants
        invariant (tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]));
        invariant (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc]));
        invariant (cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == cpu.cpu_enclave_id);
        invariant (valid_enclave_id(cpu.cpu_enclave_id) || cpu.cpu_enclave_id == tap_null_enc_id);
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==> ((tap_enclave_metadata_addr_excl[cpu.cpu_enclave_id])[cpu.cpu_pc]);
        //// OS invariants.
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==> (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc]));
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==> (cpu.cpu_owner_map[untrusted_addr_map[untrusted_pc]] == tap_null_enc_id);
        // CPU/enclave invariants.
        invariant (valid_enclave_id(cpu.cpu_enclave_id)==> tap_enclave_metadata_valid[cpu.cpu_enclave_id]);
        invariant (cpu.cpu_enclave_id != tap_blocked_enc_id);
        // enclave invariants.
        invariant (forall (e : tap_enclave_id_t) ::
                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==> 
                    tap_addr_perm_x((tap_enclave_metadata_addr_valid[cpu.cpu_enclave_id])[cpu.cpu_pc]);
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==> 
                    cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[cpu.cpu_enclave_id])[cpu.cpu_pc]] == cpu.cpu_enclave_id;
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==>
                    tap_addr_perm_x(
                        (tap_enclave_metadata_addr_valid[cpu.cpu_enclave_id])[tap_enclave_metadata_entrypoint[cpu.cpu_enclave_id]]);
        invariant (valid_enclave_id(cpu.cpu_enclave_id)) ==>
                    cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[cpu.cpu_enclave_id])[tap_enclave_metadata_entrypoint[cpu.cpu_enclave_id]]] == cpu.cpu_enclave_id;
        invariant (forall (e : tap_enclave_id_t) ::
                    tap_enclave_metadata_valid[e] ==> 
                        tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_pc[e]]));
        invariant (forall (e : tap_enclave_id_t) ::
            tap_enclave_metadata_valid[e] ==>
              tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_entrypoint[e]]));

        invariant (forall (e : tap_enclave_id_t, v : vaddr_t) ::
                    (tap_enclave_metadata_valid[e] && (tap_enclave_metadata_addr_excl[e])[v]) ==> 
                            tap_addr_perm_v((tap_enclave_metadata_addr_valid[e])[v]));
        invariant (forall (e : tap_enclave_id_t, v : vaddr_t) ::
                    (tap_enclave_metadata_valid[e] && (tap_enclave_metadata_addr_excl[e])[v]) ==> 
                            (cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[e])[v]] == e));
        invariant (forall (e : tap_enclave_id_t) ::
                    tap_enclave_metadata_valid[e] ==> 
                        (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_pc[e]]);
        invariant (forall (e : tap_enclave_id_t) ::
                    tap_enclave_metadata_valid[e] ==> 
                        (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_entrypoint[e]]);
        invariant (forall (e : tap_enclave_id_t) ::
                    tap_enclave_metadata_valid[e] ==> 
                        cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_pc[e]]] == e);
        invariant (forall (e : tap_enclave_id_t) ::
                    tap_enclave_metadata_valid[e] ==> 
                        cpu.cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_entrypoint[e]]] == e);
        // CPU/Enclave address map invariants.
        invariant (forall (va : vaddr_t) :: 
                    (cpu.cpu_enclave_id == tap_null_enc_id) ==> 
                        (cpu.cpu_addr_map[va] == untrusted_addr_map[va]));
        invariant (forall (va : vaddr_t) :: 
                    (cpu.cpu_enclave_id == tap_null_enc_id) ==> 
                        tap_addr_perm_eq(cpu.cpu_addr_valid[va], untrusted_addr_valid[va]));
        invariant (forall (va : vaddr_t) :: 
                    (cpu.cpu_enclave_id != tap_null_enc_id) ==> 
                        (cpu.cpu_addr_map[va] == (tap_enclave_metadata_addr_map[cpu.cpu_enclave_id])[va]));
        invariant (forall (va : vaddr_t) :: 
                    (cpu.cpu_enclave_id != tap_null_enc_id) ==> 
                        tap_addr_perm_eq(cpu.cpu_addr_valid[va], (tap_enclave_metadata_addr_valid[cpu.cpu_enclave_id])[va]));
        invariant  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                    (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                        (cpu.cpu_owner_map[pa] != e));
        
   {
        havoc r_eid;
        if (*) {
            havoc r_addr_valid;
            havoc r_addr_map;
            havoc r_excl_map;
            havoc r_container_valid;
            havoc r_container_data;
            havoc r_entrypoint;
            assume !r_excl_map[cpu.cpu_addr_map[cpu.cpu_pc]];
            call InitOSMem(r_container_valid, r_container_data);
            call (status) = launch(r_eid, r_addr_valid, r_addr_map, r_addr_excl, r_excl_map, r_entrypoint);
        } else {
          if (*) {
            call (status) = enter(r_eid);
          } else {
            if (*) {
              call (status) = exit();
            } else {
              if (*) {
                call (status) = resume(r_eid);
              } else {
                if (*) {
                  call (status) = pause();
                } else {
                  if (*) {
                    call (status) = destroy(r_eid);
                  } else {
                    if (*) {
                      havoc r_vaddr;
                      havoc r_word;
                      havoc repl_way;
                      assume valid_cache_way_index(repl_way);
                      call (r_excp, hit) = cpu.store_va(r_vaddr, r_word, repl_way);
                    } else {
                      if (*) {
                        call cpu.havoc_cpu_pc();
                        call cpu.havoc_cpu_regs();
                        assume (tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]));
                        assume (cpu.cpu_enclave_id != tap_null_enc_id) ==> 
                          ((tap_enclave_metadata_addr_excl[cpu.cpu_enclave_id])[cpu.cpu_pc]);
                        assume (cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == cpu.cpu_enclave_id);
                      } else {
                        if (*) {
                          if (cpu.cpu_enclave_id == tap_null_enc_id) {
                          havoc r_valid;
                          havoc r_vaddr;
                          havoc r_paddr;
                          assume r_vaddr != cpu.cpu_pc && r_vaddr != untrusted_pc;
                          call set_addr_map(r_vaddr, r_paddr, r_valid);
                          }
                        } else {
                          if (cpu.cpu_enclave_id == tap_null_enc_id) {
                            done = true;
                            assert cpu.cpu_enclave_id == tap_null_enc_id;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
}

procedure [noinline] InitOSMem(container_valid : container_valid_t, container_data : container_data_t)
    ensures (forall (p : wap_addr_t) ::
                    if (cpu.cpu_owner_map[p] == tap_null_enc_id && container_valid[p])
                        then cpu.cpu_mem[p] == container_data[p]
                        else cpu.cpu_mem[p] == old(cpu.cpu_mem)[p]);
    modifies cpu;
{}

procedure [noinline] HavocOSMem(excl_map : excl_map_t)
    ensures (forall (p : wap_addr_t) ::
                    (cpu.cpu_owner_map[p] != tap_null_enc_id || !excl_map[p])
                        ==> (cpu.cpu_mem[p] == old(cpu.cpu_mem)[p]));
    modifies cpu;
{}

procedure InitUntrustedState(_untrusted_addr_valid: addr_valid_t, _untrusted_addr_map: addr_map_t, _untrusted_pc: vaddr_t)
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_pc;
{
    untrusted_addr_valid = _untrusted_addr_valid;
    untrusted_addr_map = _untrusted_addr_map;
    untrusted_pc = _untrusted_pc;
}
  

//--------------------------------------------------------------------------//
// Utility functions for measurement theorem.                               //
//--------------------------------------------------------------------------//
procedure [inline] MeasurementEnclaveComputation(iter : integer)
    returns (vaddr : vaddr_t, data : word_t)

    modifies cpu;

    requires (tap_enclave_metadata_valid[cpu.cpu_enclave_id]);
    requires tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]);
    requires cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == cpu.cpu_enclave_id;
{
    var r0, r1  : word_t;
    var rd      : regindex_t;
    var eid     : tap_enclave_id_t;
    var pc_pa   : wap_addr_t;
    var pc_op   : word_t;
    var l_vaddr : vaddr_t;
    var l_data  : word_t;
    var s_vaddr : vaddr_t;
    var s_data  : word_t;
    var excp    : exception_t;
    var hit     : boolean;
    var way     : cache_way_index_t;

    eid = cpu.cpu_enclave_id;
    pc_pa = cpu.cpu_addr_map[cpu.cpu_pc];
    assert (tap_enclave_metadata_addr_excl[eid])[cpu.cpu_pc];
    assert cpu.cpu_owner_map[pc_pa] == eid;
    havoc way; 
    assume valid_cache_way_index(way);
    call (pc_op, excp, hit) = cpu.fetch_va(cpu.cpu_pc, way);
    assert excp == excp_none;

    // two register sources.
    r0 = cpu.cpu_regs[uf_cpu_r0_index(pc_op)];
    r1 = cpu.cpu_regs[uf_cpu_r1_index(pc_op)];

    // load address and value.
    l_vaddr = uf_mem_load_vaddr(cpu.cpu_pc, pc_op, r0, r1);
    assume tap_addr_perm_r(cpu.cpu_addr_valid[l_vaddr]);
    if((tap_enclave_metadata_addr_excl[eid])[l_vaddr]) {
        assert cpu.cpu_owner_map[cpu.cpu_addr_map[l_vaddr]] == eid;
        havoc way; 
        assume valid_cache_way_index(way);
        call (l_data, excp, hit) = cpu.load_va(l_vaddr, way);
    } else {
        l_data = uf_load_data(l_vaddr, iter);
        excp = excp_none;
        hit = false;
    }

    // get data to store to mem.
    s_vaddr = uf_mem_store_vaddr(cpu.cpu_pc, pc_op, l_data, r0, r1);
    s_data = uf_mem_store_data(cpu.cpu_pc, pc_op, l_data, r0, r1);
    assume tap_addr_perm_w(cpu.cpu_addr_valid[s_vaddr]);
    // update mem if we are writing to private memory.
    if ((tap_enclave_metadata_addr_excl[eid])[s_vaddr]) {
        assert cpu.cpu_owner_map[cpu.cpu_addr_map[s_vaddr]] == eid;
        havoc way; 
        assume valid_cache_way_index(way);
        call (excp, hit) = cpu.store_va(s_vaddr, s_data, way);
        assert excp == excp_none;
    }
    // if we're writing to shared memory, there's no point because
    // we can't expect the OS to "remember" what we wrote anyway.
    // but we do check that both enclaves write the same data to 
    // the same vaddr.
    vaddr = s_vaddr;
    data = s_data;

    // update pc.
    call cpu.set_cpu_pc(uf_cpu_pc(cpu.cpu_pc, pc_op, l_data, r0, r1));
    assume tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]);
    assume (tap_enclave_metadata_addr_excl[eid])[cpu.cpu_pc];
    assert cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == eid;
    // update regs.
    rd = uf_cpu_r2_index(pc_op);
    call cpu.update_cpu_regs(rd, uf_cpu_result(cpu.cpu_pc, pc_op, l_data, r0, r1));
}
                      
define is_measurement_untrusted_op(op : tap_proof_op_t) : boolean
= op == tap_proof_op_resume || op == tap_proof_op_enter;


define is_measurement_enclave_op(op : tap_proof_op_t) : boolean
= op == tap_proof_op_compute    ||
  op == tap_proof_op_pause      ||
  op == tap_proof_op_exit;


procedure [inline] MeasurementUntrustedOp(
    /* operation */ op   : tap_proof_op_t, 
    /* enclave   */ eid  : tap_enclave_id_t,
    /* args      */ regs : regs_t
) 
  returns (status : enclave_op_result_t, current_mode : mode_t)
  ensures (current_mode == mode_untrusted ==> cpu.cpu_enclave_id == tap_null_enc_id);
  modifies untrusted_addr_valid;
  modifies untrusted_addr_map;
  modifies untrusted_regs;
  modifies untrusted_pc;
  modifies tap_enclave_metadata_valid;
  modifies tap_enclave_metadata_addr_map;
  modifies tap_enclave_metadata_addr_valid;
  modifies tap_enclave_metadata_entrypoint;
  modifies tap_enclave_metadata_pc;
  modifies tap_enclave_metadata_regs;
  modifies tap_enclave_metadata_paused;
  modifies tap_enclave_metadata_cache_conflict;
  modifies cpu;
  modifies see;
{
    assert (is_measurement_untrusted_op(op));
    status = enclave_op_success;
    if (op == tap_proof_op_enter) {
        call cpu.set_cpu_regs(regs);
        assert(cpu.cpu_enclave_id == tap_null_enc_id);
        call simple_test();
        assert false;
        call (status) = enter(eid);
        assert status == enclave_op_success;
        current_mode = mode_enclave;
    } else {
        if (op == tap_proof_op_resume) {
          call (status) = resume(eid);
          if (status == enclave_op_success) {
              current_mode = mode_enclave;
          } else {
              current_mode = mode_untrusted;
          }
        }
    }
}

procedure [inline] MeasurementEnclaveOp(
    /* operation */ op   : tap_proof_op_t,
    /* iteration */ iter : integer
) 
  returns (status : enclave_op_result_t, current_mode : mode_t, vaddr : vaddr_t, word : word_t)
  modifies untrusted_addr_valid;
  modifies untrusted_addr_map;
  modifies untrusted_regs;
  modifies untrusted_pc;
  modifies tap_enclave_metadata_valid;
  modifies tap_enclave_metadata_addr_map;
  modifies tap_enclave_metadata_addr_valid;
  modifies tap_enclave_metadata_entrypoint;
  modifies tap_enclave_metadata_pc;
  modifies tap_enclave_metadata_regs;
  modifies tap_enclave_metadata_paused;
  modifies tap_enclave_metadata_cache_conflict;
  modifies cpu;
{
    assert (is_measurement_enclave_op(op));
    vaddr = k0_vaddr_t;
    word  = k0_word_t;
    case 
      (op == tap_proof_op_compute) : {
        call (vaddr, word) = MeasurementEnclaveComputation(iter);
        status = enclave_op_success;
        current_mode = mode_enclave;
      } 
      (op == tap_proof_op_exit) : {
        call (status) = exit();
        current_mode = mode_untrusted;
      } 
      (op == tap_proof_op_pause) : {
        call (status) = pause();
        current_mode = mode_untrusted;
      }
    esac
    assert status == enclave_op_success;
}

//
// Utility functions for integrity proofs
//
// The computation performed by the enclave.
procedure [inline] EnclaveComputation(iter : integer)
    returns (vaddr : vaddr_t, paddr : wap_addr_t, data : word_t)

    requires (tap_enclave_metadata_valid[cpu.cpu_enclave_id]);
    requires tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]);
    requires cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == cpu.cpu_enclave_id;

    modifies cpu;
{
    var r0, r1  : word_t;
    var rd      : regindex_t;
    var eid     : tap_enclave_id_t;
    var pc_pa   : wap_addr_t;
    var pc_op   : word_t;
    var l_vaddr : vaddr_t;
    var l_data  : word_t;
    var s_vaddr : vaddr_t;
    var s_data  : word_t;
    var excp    : exception_t;
    var hit     : boolean;
    var way     : cache_way_index_t;

    eid = cpu.cpu_enclave_id;
    pc_pa = cpu.cpu_addr_map[cpu.cpu_pc];
    assert tap_enclave_metadata_addr_excl[eid][cpu.cpu_pc];
    assert tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]);

    havoc way; 
    assume valid_cache_way_index(way);

    call (pc_op, excp, hit) = cpu.fetch_va(cpu.cpu_pc, way);
    assert excp == excp_none;

    // two register sources.
    r0 = cpu.cpu_regs[uf_cpu_r0_index(pc_op)];
    r1 = cpu.cpu_regs[uf_cpu_r1_index(pc_op)];

    // load address and value.
    l_vaddr = ap_types.uf_mem_load_vaddr(cpu.cpu_pc, pc_op, r0, r1);
    assume tap_addr_perm_r(cpu.cpu_addr_valid[l_vaddr]);
    if (tap_enclave_metadata_addr_excl[eid][l_vaddr]) {
        assert cpu.cpu_owner_map[cpu.cpu_addr_map[l_vaddr]] == eid;

        havoc way; 
        assume valid_cache_way_index(way);

        call (l_data, excp, hit) = cpu.load_va(l_vaddr, way);
        assert excp == excp_none;
    } else {
        hit = false;
        excp = excp_none;
        l_data = uf_load_data(l_vaddr, iter);
    }

    // get data to store to mem.
    s_vaddr = uf_mem_store_vaddr(cpu.cpu_pc, pc_op, l_data, r0, r1);
    s_data = ap_types.uf_mem_store_data(cpu.cpu_pc, pc_op, l_data, r0, r1);
    vaddr = s_vaddr;
    paddr = cpu.cpu_addr_map[s_vaddr];
    data = s_data;

    // update mem.
    assume tap_addr_perm_w(cpu.cpu_addr_valid[s_vaddr]);
    if (tap_enclave_metadata_addr_excl[eid][s_vaddr]) {
        assert (cpu.cpu_owner_map[cpu.cpu_addr_map[s_vaddr]] == eid);

        havoc way; 
        assume valid_cache_way_index(way);

        call (excp, hit) = cpu.store_va(s_vaddr, s_data, way);
        assert excp == excp_none;
    }

    // update pc.
    call cpu.set_cpu_pc(uf_cpu_pc(cpu.cpu_pc, pc_op, l_data, r0, r1));
    assume tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]);
    assume tap_enclave_metadata_addr_excl[eid][cpu.cpu_pc];
    assert cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == eid;
    // update regs.
    rd = uf_cpu_r2_index(pc_op);
    call cpu.update_cpu_regs(rd, uf_cpu_result(cpu.cpu_pc, pc_op, l_data, r0, r1));
}

procedure [inline] IntegrityAdversarialStep(
    /* mode       */ mode       : mode_t,
    /* EuT        */ eid        : tap_enclave_id_t,
    /* Adversary  */ r_eid      : tap_enclave_id_t,
    /* args       */ r_regs     : regs_t,
    /* operation  */ op         : tap_proof_op_t
)

    returns (next_mode : mode_t, enclave_dead : boolean)
    
    //ensures (op != tap_proof_op_enter &&  op != tap_proof_op_resume)
    //  ==> next_mode == mode;
    //
    ////ensures ((op == tap_proof_op_enter || op == tap_proof_op_resume) && 
    ////         mode ==  mode_untrusted)
    ////          ==> (current_mode == mode_enclave);
    //
    //ensures (!(op == tap_proof_op_enter || op == tap_proof_op_resume) &&
    //         mode == mode_untrusted)
    //          ==> (next_mode == mode_untrusted);

    //ensures (op == tap_proof_op_compute
    //          ==> next_mode == mode);


    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_regs;
    modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_excl;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu;
{
    var status            : enclave_op_result_t;
    var r_addr_valid      : addr_valid_t;
    var r_addr_map        : addr_map_t;
    var r_excl_vaddr      : excl_vaddr_t;
    var r_excl_map        : excl_map_t;
    var r_container_valid : container_valid_t;
    var r_container_data  : container_data_t;
    var r_entrypoint      : vaddr_t;
    var r_vaddr           : vaddr_t;
    var r_valid           : addr_perm_t;
    var r_excp            : exception_t;
    var r_paddr           : wap_addr_t;
    var r_word            : word_t;
    var r_bmap            : excl_map_t;
    var hit               : boolean;
    var way               : cache_way_index_t;

    // the "default" value which may be overwritten by enter/resume
    next_mode = mode;
    // the "default" value which may be overwritten by destroy.
    enclave_dead = false;

    case 
    (op == tap_proof_op_launch) : {            
        // launch
        call InitOSMem(r_container_valid, r_container_data);
        call (status) = launch(r_eid, r_addr_valid, r_addr_map, 
                              r_excl_vaddr, r_excl_map, r_entrypoint);
        assert (r_eid == eid) ==> (status != enclave_op_success);
    } 
    (op == tap_proof_op_enter) : {      
        // enter
        call cpu.set_cpu_regs(r_regs);
        call (status) = enter(r_eid);
        // mode == mode_enclave means we are in trace_2.
        assert (mode == mode_enclave ==> status == enclave_op_success);
        if (status == enclave_op_success && r_eid == eid) { 
            next_mode = mode_enclave; 
        }
        assert ((status == enclave_op_success && r_eid == eid)
                ==> next_mode == mode_enclave);
    } 
    (op == tap_proof_op_resume) : {     
        // resume
        call (status) = resume(r_eid);
        // mode == mode_enclave means we are in trace_2.
        assert (mode == mode_enclave ==> status == enclave_op_success);
        if (status == enclave_op_success && r_eid == eid) { 
            next_mode = mode_enclave; 
        }
        assert ((status == enclave_op_success && r_eid == eid)
                ==> next_mode == mode_enclave);
    } 
    (op == tap_proof_op_exit) : {       
        // exit
        call (status) = exit();
    } 
    (op == tap_proof_op_pause) : {      
        // pause.
        call (status) = pause();
    } 
    (op == tap_proof_op_destroy) : {    
        // destroy.
        call (status) = destroy(r_eid);
        if (r_eid == eid && status == enclave_op_success) {
            enclave_dead = true;
        }
        assert(mode == mode_untrusted ==> next_mode != mode_enclave);
    } 
    (op == tap_proof_op_release) : {
        call (status) = release_blocked_memory(r_bmap);
    } 
    (op == tap_proof_op_block) : {
        call (status) = block_memory_region(r_bmap);
    } 
    (op == tap_proof_op_compute) : {    
        // some adversarial computation
        if (*) {
            havoc r_vaddr;
            havoc r_word;
            havoc way; assume valid_cache_way_index(way);
            call (r_excp, hit) = cpu.store_va(r_vaddr, r_word, way);
        } else {
            if (*) {
                call cpu.havoc_cpu_pc();
                call cpu.havoc_cpu_regs();
            } else {
                if (*) {
                    // update "page" table map.
                    havoc r_vaddr;
                    havoc r_paddr;
                    havoc r_valid;
                    call cpu.update_cpu_addr_valid(r_vaddr, r_valid);
                    call cpu.update_cpu_addr_map(r_vaddr, r_paddr);
                } else {
                    if (*) {
                        havoc r_vaddr;
                        havoc r_paddr;
                        havoc r_valid;
                        call (status) = set_enclave_addr_map(r_eid, r_vaddr, r_valid, r_paddr);
                    }
                }
            }
        }
    }
    esac
    assert (op != tap_proof_op_enter && op != tap_proof_op_resume)
      ==> next_mode == mode;
} 

define tap_proof_op_valid_in_enclave(o : tap_proof_op_t) : boolean
= (o == tap_proof_op_compute) ||
  (o == tap_proof_op_pause)   ||
  (o == tap_proof_op_exit);

procedure [inline] IntegrityEnclaveStep(
    /* what operation?  */  op : tap_proof_op_t, 
    /* which iteration? */  iter : integer
)
    returns (next_mode : mode_t, vaddr : vaddr_t, paddr : wap_addr_t, data : word_t)

    ensures (op == tap_proof_op_compute ==> next_mode == mode_enclave);
    ensures (op != tap_proof_op_compute ==> next_mode == mode_untrusted);

    //modifies untrusted_addr_valid;
    //modifies untrusted_addr_map;
    //modifies untrusted_regs;
    //modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    //modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    //modifies tap_enclave_metadata_cache_conflict;
    modifies cpu;
{
    var status : enclave_op_result_t;
    assert tap_proof_op_valid_in_enclave(op);

    vaddr = k0_vaddr_t;
    paddr = k0_wap_addr_t;
    data = k0_word_t;

    // in enclave-mode:
    case
    (op == tap_proof_op_compute) : {
        call (vaddr, paddr, data) = EnclaveComputation(iter);
        next_mode = mode_enclave;
    } 
    (op == tap_proof_op_pause) : {
        call (status) = pause();
        assert status == enclave_op_success;
        next_mode = mode_untrusted;
    }
    (op == tap_proof_op_exit) : {
        call (status) = exit();
        assert status == enclave_op_success;
        next_mode = mode_untrusted;
    }
    esac
}



//
// Utilities for confidentiality proofs
//
procedure [inline] MemObserverComputation(
    /* next PC value.           */  r_pc : vaddr_t,
    /* registers to read/write. */  r_read : regindex_t, r_write : regindex_t, r_data: word_t,
    /* mem. to read/write.      */  l_vaddr: vaddr_t, s_vaddr: vaddr_t, s_data : word_t,
    /* "pt" entry to read       */  r_pt_eid : tap_enclave_id_t, r_pt_va : vaddr_t,
    /* "pt" entry to change.    */  pt_eid : tap_enclave_id_t, pt_vaddr: vaddr_t, 
    /* "pt" entry to change.    */  pt_valid: addr_perm_t, pt_paddr: wap_addr_t)
    returns (observation : word_t)
    requires valid_regindex(r_read);
    requires valid_regindex(r_write);

    modifies untrusted_addr_valid;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies untrusted_addr_map;
    modifies cpu;
{
    var excp         : exception_t;
    var l_word       : word_t;
    var r_word       : word_t;
    var hit_1, hit_2 : boolean;
    var valid        : addr_perm_t;
    var paddr        : wap_addr_t;
    var status       : enclave_op_result_t;
    var l_way, s_way : cache_way_index_t;

    assume valid_cache_way_index(l_way);
    assume valid_cache_way_index(s_way);

    call cpu.set_cpu_pc(r_pc);
    call cpu.update_cpu_regs(r_write, r_data);
    // store
    call (excp, hit_1) = cpu.store_va(s_vaddr, s_data, s_way);
    // load
    call (l_word, excp, hit_2) = cpu.load_va(l_vaddr, l_way);
    r_word = cpu.cpu_regs[r_read];
    observation = uf_observation_mem(cpu.cpu_pc, l_word, r_word);

    if (pt_eid == tap_null_enc_id) {
        call set_addr_map(pt_vaddr, pt_paddr, pt_valid);
    } else {
        call (status) = set_enclave_addr_map(pt_eid, pt_vaddr, pt_valid, pt_paddr);
    }
}


procedure [inline] CacheObserverComputation(
    /* next PC value.           */  r_pc : vaddr_t,
    /* registers to read/write. */  r_read : regindex_t, r_write : regindex_t, r_data: word_t,
    /* mem. to read/write.      */  l_vaddr: vaddr_t, s_vaddr: vaddr_t, s_data : word_t,
    /* "pt" entry to read       */  r_pt_eid : tap_enclave_id_t, r_pt_va : vaddr_t,
    /* "pt" entry to change.    */  pt_eid : tap_enclave_id_t, pt_vaddr: vaddr_t, 
    /* "pt" entry to change.    */  pt_valid: addr_perm_t, pt_paddr: wap_addr_t,
    /* ways to change.          */  l_way, s_way : cache_way_index_t)
    returns (observation : word_t, hit_1 : boolean, hit_2 : boolean,
             excp_1 : exception_t, excp_2 : exception_t)
    requires valid_regindex(r_read);
    requires valid_regindex(r_write);
    requires valid_cache_way_index(s_way);
    requires valid_cache_way_index(l_way);

    ensures ((!tap_addr_perm_w(old(cpu.cpu_addr_valid)[s_vaddr]) ||
              (cpu.cpu_owner_map[old(cpu.cpu_addr_map)[s_vaddr]] != tap_null_enc_id && cpu.cpu_owner_map[old(cpu.cpu_addr_map)[s_vaddr]] != cpu.cpu_enclave_id)) &&
             (!tap_addr_perm_r(old(cpu.cpu_addr_valid)[l_vaddr]) ||
              (cpu.cpu_owner_map[old(cpu.cpu_addr_map)[l_vaddr]] != tap_null_enc_id && cpu.cpu_owner_map[old(cpu.cpu_addr_map)[l_vaddr]] != cpu.cpu_enclave_id)))
             ==> (observation == uf_observation_cache(false, false));

    ensures (forall (p : wap_addr_t, w : cache_way_index_t) ::
               ((paddr2set(p) != paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) || w != s_way) && 
                (paddr2set(p) != paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) || w != l_way))
                  ==> ((cpu.cache.cache_valid_map[paddr2set(p), w] == old(cpu.cache.cache_valid_map)[paddr2set(p), w]) &&
                       (cpu.cache.cache_tag_map[paddr2set(p), w] == old(cpu.cache.cache_tag_map)[paddr2set(p), w])));
    ensures (cpu.cpu_cache_enabled) ==>
            (forall (p : wap_addr_t, w : cache_way_index_t) ::
                    ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) && w == s_way) &&
                    (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                    (excp_1 != excp_none || hit_1))
                    ==> 
                        (cpu.cache.cache_valid_map[paddr2set(p), w] == old(cpu.cache.cache_valid_map)[paddr2set(p), w] &&
                         cpu.cache.cache_tag_map[paddr2set(p), w] == old(cpu.cache.cache_tag_map)[paddr2set(p), w]));

    ensures (cpu.cpu_cache_enabled) ==>
            (forall (p : wap_addr_t, w : cache_way_index_t) ::
                    ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) && w == s_way) &&
                    (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                    (excp_1 == excp_none && !hit_1))
                    ==> 
                        (cpu.cache.cache_valid_map[paddr2set(p), w] == true &&
                         cpu.cache.cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu.cpu_addr_map)[s_vaddr])));

    ensures (cpu.cpu_cache_enabled) ==>
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                    ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) && w == l_way) &&
                    (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                    (excp_2 != excp_none || hit_2))
                    ==> 
                        (cpu.cache.cache_valid_map[paddr2set(p), w] == old(cpu.cache.cache_valid_map)[paddr2set(p), w] &&
                         cpu.cache.cache_tag_map[paddr2set(p), w] == old(cpu.cache.cache_tag_map)[paddr2set(p), w]));

    ensures (cpu.cpu_cache_enabled) ==>
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                    ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) && w == l_way) &&
                    (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                    (excp_2 == excp_none && !hit_2))
                    ==> 
                        (cpu.cache.cache_valid_map[paddr2set(p), w] == true &&
                         cpu.cache.cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu.cpu_addr_map)[l_vaddr])));

    // Invariants for when s_vaddr and p_addr map to the same location in the cache
    ensures (cpu.cpu_cache_enabled) ==>
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) && w == s_way) &&
                 (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) == paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) && s_way == l_way) &&
                  ((hit_1 && hit_2) || 
                   (excp_2 != excp_none && hit_1 && !hit_2) ||
                   (excp_1 != excp_none && !hit_1 && hit_2) ||
                   (excp_1 != excp_none && excp_2 != excp_none)))
                ==> (cpu.cache.cache_valid_map[paddr2set(p), w] == old(cpu.cache.cache_valid_map)[paddr2set(p), w] && 
                     cpu.cache.cache_tag_map[paddr2set(p), w] == old(cpu.cache.cache_tag_map)[paddr2set(p), w]));

    ensures (cpu.cpu_cache_enabled) ==> 
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) && w == s_way) &&
                 (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) == paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) && s_way == l_way) &&
                  ((excp_2 == excp_none && hit_1 && !hit_2) ||
                   (excp_1 != excp_none && excp_2 == excp_none && !hit_1 && !hit_2) ||
                   (excp_1 == excp_none && excp_2 == excp_none && !hit_1 && !hit_2)))
                ==> (cpu.cache.cache_valid_map[paddr2set(p), w] == true &&
                     cpu.cache.cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu.cpu_addr_map)[l_vaddr])));

    ensures (cpu.cpu_cache_enabled) ==> 
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                ((paddr2set(p) == paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) && w == s_way) &&
                 (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) == paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) && s_way == l_way) &&
                   ((excp_1 == excp_none && !hit_1 && hit_2) ||
                    (excp_1 == excp_none && excp_2 != excp_none && !hit_1 && !hit_2)))
                ==> (cpu.cache.cache_valid_map[paddr2set(p), w] == true &&
                     cpu.cache.cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu.cpu_addr_map)[s_vaddr])));

  
    ensures (s_vaddr != l_vaddr || s_way != l_way)
              ==> ((cpu.cache.cache_valid_map[paddr2set(old(cpu.cpu_addr_map)[s_vaddr]), s_way] == old(cpu.cache.cache_valid_map)[paddr2set(old(cpu.cpu_addr_map)[s_vaddr]), s_way]) ||
                   (cpu.cache.cache_valid_map[paddr2set(old(cpu.cpu_addr_map)[s_vaddr]), s_way] == true));
    ensures ((cpu.cache.cache_valid_map[paddr2set(old(cpu.cpu_addr_map)[l_vaddr]), l_way] == old(cpu.cache.cache_valid_map)[paddr2set(old(cpu.cpu_addr_map)[l_vaddr]), l_way]) ||
                   (cpu.cache.cache_valid_map[paddr2set(old(cpu.cpu_addr_map)[l_vaddr]), l_way] == true));

    ensures (!cpu.cpu_cache_enabled) ==> 
              (cpu.cache.cache_valid_map == old(cpu.cache.cache_valid_map) && cpu.cache.cache_tag_map == old(cpu.cache.cache_tag_map));

    ensures (excp_1 == excp_none && cpu.cpu_cache_enabled && !hit_1 &&
             (paddr2set(old(cpu.cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu.cpu_addr_map)[l_vaddr]) || s_way != l_way)) 
              ==> ((cpu.cache.cache_valid_map[paddr2set(old(cpu.cpu_addr_map)[s_vaddr]), s_way] == true) &&
                    (cpu.cache.cache_tag_map[paddr2set(old(cpu.cpu_addr_map)[s_vaddr]), s_way] == paddr2tag(old(cpu.cpu_addr_map)[s_vaddr])));
    
    ensures (excp_2 == excp_none && cpu.cpu_cache_enabled && !hit_2)
              ==> ((cpu.cache.cache_valid_map[paddr2set(old(cpu.cpu_addr_map)[l_vaddr]), l_way] == true) &&
                    (cpu.cache.cache_tag_map[paddr2set(old(cpu.cpu_addr_map)[l_vaddr]), l_way] == paddr2tag(old(cpu.cpu_addr_map)[l_vaddr])));

    

    ensures (cpu.cpu_cache_enabled && hit_1 && hit_2)
            ==> (cpu.cache.cache_valid_map == old(cpu.cache.cache_valid_map) && cpu.cache.cache_tag_map == old(cpu.cache.cache_tag_map));


    ensures (excp_1 != excp_none) ==> (hit_1 == false);
    ensures (excp_2 != excp_none) ==> (hit_2 == false);
    ensures (!cpu.cpu_cache_enabled) ==> (hit_1 == false && hit_2 == false);





 
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies cpu;
{
    var excp         : exception_t;
    var l_word       : word_t;
    var r_word       : word_t;
    var valid        : addr_perm_t;
    var paddr        : wap_addr_t;
    var status       : enclave_op_result_t;

    call cpu.set_cpu_pc(r_pc);
    call cpu.update_cpu_regs(r_write, r_data);
    call (excp_1, hit_1) = cpu.store_va(s_vaddr, s_data, s_way);
    call (valid, paddr) = get_enclave_addr_map(r_pt_eid, r_pt_va);
    call (l_word, excp_2, hit_2) = cpu.load_va(l_vaddr, l_way);
    r_word = cpu.cpu_regs[r_read];
    observation = uf_observation_cache(hit_1, hit_2);

    if (pt_eid == tap_null_enc_id) {
        call set_addr_map(pt_vaddr, pt_paddr, pt_valid);
    } else {
        call (status) = set_enclave_addr_map(pt_eid, pt_vaddr, pt_valid, pt_paddr);
    }
}


procedure [inline] PTObserverComputation(
    /* next PC value.           */  r_pc : vaddr_t,
    /* registers to read/write. */  r_read : regindex_t, r_write : regindex_t, r_data: word_t,
    /* mem. to read/write.      */  l_vaddr: vaddr_t, s_vaddr: vaddr_t, s_data : word_t,
    /* "pt" entry to read       */  r_pt_eid : tap_enclave_id_t, r_pt_va : vaddr_t,
    /* "pt" entry to change.    */  pt_eid : tap_enclave_id_t, pt_vaddr: vaddr_t, 
    /* "pt" entry to change.    */  pt_valid: addr_perm_t, pt_paddr: wap_addr_t)
    returns (observation : word_t, excp : exception_t)
    requires valid_regindex(r_read);
    requires valid_regindex(r_write);
    ensures (pt_eid == tap_null_enc_id && cpu.cpu_enclave_id == tap_null_enc_id)
              ==> ((forall (va : vaddr_t) ::
                    (va != pt_vaddr) ==>
                      (cpu.cpu_addr_valid[va] == old(untrusted_addr_valid)[va])) &&
                    (cpu.cpu_addr_valid[pt_vaddr] == pt_valid));
    ensures (pt_eid == tap_null_enc_id && cpu.cpu_enclave_id != tap_null_enc_id)
              ==> (forall (va : vaddr_t) ::
                    (va != s_vaddr)
                      ==> (cpu.cpu_addr_valid[va] == old(cpu.cpu_addr_valid)[va]));
    ensures (pt_eid != tap_null_enc_id)
              ==> (forall (va : vaddr_t) ::
                    (va != s_vaddr)
                      ==> (cpu.cpu_addr_valid[va] == old(cpu.cpu_addr_valid)[va]));
    ensures (pt_eid != tap_null_enc_id && excp == excp_none)
              ==> (cpu.cpu_addr_valid[s_vaddr] == tap_set_addr_perm_a(old(cpu.cpu_addr_valid)[s_vaddr]));
    ensures (pt_eid != tap_null_enc_id && excp != excp_none)
            ==> (cpu.cpu_addr_valid[s_vaddr] == old(cpu.cpu_addr_valid)[s_vaddr]);
    ensures (pt_eid == tap_null_enc_id && cpu.cpu_enclave_id != tap_null_enc_id  && excp == excp_none)
              ==> (cpu.cpu_addr_valid[s_vaddr] == tap_set_addr_perm_a(old(cpu.cpu_addr_valid)[s_vaddr]));
    ensures (pt_eid == tap_null_enc_id && cpu.cpu_enclave_id != tap_null_enc_id &&  excp != excp_none)
            ==> (cpu.cpu_addr_valid[s_vaddr] == old(cpu.cpu_addr_valid)[s_vaddr]);
    ensures (block_os_ev_read && (tap_enclave_metadata_addr_excl[r_pt_eid])[r_pt_va])
            ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));
    ensures (cpu.cpu_enclave_id != tap_null_enc_id || !tap_enclave_metadata_valid[r_pt_eid])
            ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));
    ensures (cpu.cpu_enclave_id == tap_null_enc_id && tap_enclave_metadata_valid[r_pt_eid] && (!block_os_ev_read || !((tap_enclave_metadata_addr_excl[r_pt_eid])[r_pt_va])))
            ==> (observation == uf_observation_pt(
                             (old(tap_enclave_metadata_addr_valid)[r_pt_eid])[r_pt_va],
                             (old(tap_enclave_metadata_addr_map)[r_pt_eid])[r_pt_va]));



    
    
 
    modifies untrusted_addr_valid;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies untrusted_addr_map;
    modifies cpu;
{
    var l_word       : word_t;
    var r_word       : word_t;
    var hit_1, hit_2 : boolean;
    var valid        : addr_perm_t;
    var paddr        : wap_addr_t;
    var status       : enclave_op_result_t;
    var l_way, s_way : cache_way_index_t;
    
    havoc excp;

    assume (excp != excp_none);
    assume valid_cache_way_index(l_way);
    assume valid_cache_way_index(s_way);

    // make observation.
    call (valid, paddr) = get_enclave_addr_map(r_pt_eid, r_pt_va);
    observation = uf_observation_pt(valid, paddr);

    // change state.
    call cpu.set_cpu_pc(r_pc);
    call cpu.update_cpu_regs(r_write, r_data);
    call (excp, hit_1) = cpu.store_va(s_vaddr, s_data, s_way);
    if (pt_eid == tap_null_enc_id) {
        call set_addr_map(pt_vaddr, pt_paddr, pt_valid);
    } else {
        call (status) = set_enclave_addr_map(pt_eid, pt_vaddr, pt_valid, pt_paddr);
    }
}


procedure [inline] ObserverStep(
    /* observer          */ observer          : observer_t,
    /* Current mode      */ mode              : mode_t,
    /* Secret Enclave    */ eid               : tap_enclave_id_t,
    /* Adversary Enclave */ r_eid             : tap_enclave_id_t,
    /* Operation.        */ op                : tap_proof_op_t,
    /* next PC value.    */ r_pc              : vaddr_t,
    /* reg to read.      */ r_read            : regindex_t,
    /* reg to write      */ r_write           : regindex_t,
    /* data to write     */ r_data            : word_t,
    /* mem. to read.     */ l_vaddr           : vaddr_t,
    /* mem to write      */ s_vaddr           : vaddr_t,
    /* data to write     */ s_data            : word_t,
    /* pt entry to read  */ r_pt_eid          : tap_enclave_id_t, 
    /* pt entry to read  */ r_pt_va           : vaddr_t,
    /* pt eid            */ pt_eid            : tap_enclave_id_t,
    /* pt vaddr          */ pt_vaddr          : vaddr_t,
    /* pt valid          */ pt_valid          : addr_perm_t,
    /* pt paddr          */ pt_paddr          : wap_addr_t,
    /* VA->PA valid      */ r_addr_valid      : addr_valid_t,
    /* VA->PA map        */ r_addr_map        : addr_map_t,
    /* VA->excl map      */ r_excl_vaddr      : excl_vaddr_t,
    /* Private Mem Map   */ r_excl_map        : excl_map_t,
    /* Container Valid   */ r_container_valid : container_valid_t,
    /* Container Data    */ r_container_data  : container_data_t,
    /* Entrypoint        */ r_entrypoint      : vaddr_t,
    /* blocked mem       */ r_bmap            : excl_map_t,
    /* ways to change.   */ l_way, s_way      : cache_way_index_t)

    returns (observation: word_t, next_mode : mode_t, enclave_dead : boolean, status : enclave_op_result_t, excp_1 : exception_t, excp_2 : exception_t, hit_1 : boolean, hit_2 : boolean)
    // PC stays reasonable.
    // Don't mess up TAP invariants.
    requires valid_regindex(r_read);
    requires valid_regindex(r_write);
    requires (observer == k_mem_observer_t   || 
              observer == k_cache_observer_t ||
              observer == k_pt_observer_t);

    requires valid_cache_way_index(s_way);
    requires valid_cache_way_index(l_way);

    
    ensures (op == tap_proof_op_compute) ==> 
                (cpu.cpu_enclave_id == old(cpu.cpu_enclave_id) &&
                 tap_enclave_metadata_valid == old(tap_enclave_metadata_valid) &&
                 tap_enclave_metadata_addr_excl == old(tap_enclave_metadata_addr_excl));




    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_regs;
    modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_excl;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu;
{
    // "default" for the next mode.
    next_mode = mode;
    // "default" for whether we kill enclave eid.
    enclave_dead = false;

    // start with a dummy observation.
    observation = k0_word_t;
    status = enclave_op_success;
    havoc excp_1;
    havoc excp_2;
    assume (excp_1 != excp_none);
    assume (excp_2 != excp_none);
    hit_1 = false;
    hit_2 = false;

    case
    (op == tap_proof_op_compute) : {
        case
        (observer == k_mem_observer_t) : {
            call (observation) = MemObserverComputation(r_pc, r_read, r_write, r_data,
                                                       l_vaddr, s_vaddr, s_data,
                                                       r_pt_eid, r_pt_va,
                                                       pt_eid, pt_vaddr, pt_valid, pt_paddr);
        } 
        (observer == k_cache_observer_t) : {
            call (observation, hit_1, hit_2, excp_1, excp_2) = CacheObserverComputation(r_pc, r_read, r_write, r_data,
                                                         l_vaddr, s_vaddr, s_data,
                                                         r_pt_eid, r_pt_va,
                                                         pt_eid, pt_vaddr, pt_valid, pt_paddr,
                                                         l_way, s_way);
        } 
        (observer == k_pt_observer_t) : {
            call (observation, excp_1) = PTObserverComputation(r_pc, r_read, r_write, r_data,
                                                      l_vaddr, s_vaddr, s_data,
                                                      r_pt_eid, r_pt_va,
                                                      pt_eid, pt_vaddr, pt_valid, pt_paddr);
            assert (block_os_ev_read && (tap_enclave_metadata_addr_excl[r_pt_eid])[r_pt_va])
            ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));
            assert (cpu.cpu_enclave_id != tap_null_enc_id || !tap_enclave_metadata_valid[r_pt_eid])
            ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));

        }
        esac
    } 
    (op == tap_proof_op_launch) : {
        // can't put current pc inside the enclave.
        assume !r_excl_map[cpu.cpu_addr_map[cpu.cpu_pc]];
        call InitOSMem(r_container_valid, r_container_data);
        call (status) = launch(r_eid, r_addr_valid, r_addr_map, 
                              r_excl_vaddr, r_excl_map, r_entrypoint);
        assert (r_eid == eid) ==> (status != enclave_op_success);
    } 
    (op == tap_proof_op_destroy) : {
        call (status) = destroy(r_eid);
        // the enclave has been destroyed.
        if (r_eid == eid && status == enclave_op_success) {
            enclave_dead = true;
        }
    } 
    (op == tap_proof_op_enter) : {
        call (status) = enter(r_eid);
        assert (cpu.cpu_enclave_id == tap_null_enc_id && r_eid == eid) ==> 
                (status == enclave_op_success);
        // switch to enclave mode.
        if (r_eid == eid && status == enclave_op_success) {
            next_mode = mode_enclave;
        }
    } 
    (op == tap_proof_op_exit) : {
        call (status) = exit();
    } 
    (op == tap_proof_op_resume) : {
        call (status) = resume(r_eid);
        // switch to enclave mode.
        assert (cpu.cpu_enclave_id == tap_null_enc_id && r_eid == eid && tap_enclave_metadata_paused[eid]) ==> 
                (status == enclave_op_success);
        if (r_eid == eid && status == enclave_op_success) {
            next_mode = mode_enclave;
        }
    } 
    (op == tap_proof_op_pause) : {
        call (status) = pause();
    } 
    (op == tap_proof_op_release) : {
        call (status) = release_blocked_memory(r_bmap);
    } 
    (op == tap_proof_op_block) : {
        call (status) = block_memory_region(r_bmap);
    }
    esac
}

procedure [inline] EnclaveStep(
    /* Current mode */      mode              : mode_t,
    /* Secret Enclave */    eid               : tap_enclave_id_t,
    /* Operation. */        op                : tap_proof_op_t)

    returns (
        /* mode     */  next_mode : mode_t, 
        /* read     */  load_addr : vaddr_t, l_way : cache_way_index_t,
        /* store    */  store_addr : vaddr_t, store_data : word_t, s_way : cache_way_index_t
    )
    //modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_excl;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu;
{
    var vaddr  : vaddr_t;
    var word   : word_t;
    var excp   : exception_t;
    var status : enclave_op_result_t;
    var hit    : boolean;
    var owner  : tap_enclave_id_t;
    var way    : cache_way_index_t;

    case
    (op == tap_proof_op_compute) : {
        // do whatever.
        call cpu.havoc_cpu_pc();
        call cpu.havoc_cpu_regs();

        // fetch from whereever inside the enclave.
        assume tap_enclave_metadata_addr_excl[eid][cpu.cpu_pc];
        assume tap_addr_perm_x(cpu.cpu_addr_valid[cpu.cpu_pc]);
        assert cpu.cpu_owner_map[cpu.cpu_addr_map[cpu.cpu_pc]] == eid;
        havoc way; assume valid_cache_way_index(way);
        call (word, excp, hit) = cpu.fetch_va(cpu.cpu_pc, way);
        assert (excp == excp_none);

        // load from whereever inside the enclave.
        havoc load_addr;
        assume tap_addr_perm_r(cpu.cpu_addr_valid[load_addr]);
        owner = cpu.cpu_owner_map[cpu.cpu_addr_map[load_addr]];
        assume owner == eid || owner == tap_null_enc_id;
        havoc l_way; assume valid_cache_way_index(l_way);
        call (word, excp, hit) = cpu.load_va(load_addr, l_way);
        assert (excp == excp_none);

        // store whatever inside the enclave.
        havoc store_addr; havoc store_data;
        assume tap_addr_perm_w(cpu.cpu_addr_valid[store_addr]);
        owner = cpu.cpu_owner_map[cpu.cpu_addr_map[store_addr]];
        assume owner == eid || owner == tap_null_enc_id;
        havoc s_way; assume valid_cache_way_index(s_way);
        call (excp, hit) = cpu.store_va(store_addr, store_data, s_way);
        assert excp == excp_none;
        store_data = store_data;

        // stay in the same mode.
        next_mode = mode;
    } 
    (op == tap_proof_op_exit) : {
        call (status) = exit();
        assert status == enclave_op_success;
        // switch back to the observer. 
        next_mode = mode_untrusted;
    } 
    (op == tap_proof_op_pause) : {
        //call (status) = exit();
        call (status) = pause();
        assert status == enclave_op_success;
        // switch back to the observer. 
        next_mode = mode_untrusted;
    }
    esac
}

procedure [inline] SetInitState(
  _cpu_mem : mem_t,
  _cpu_regs : regs_t,
  _cpu_pc : vaddr_t,
  _cpu_enclave_id : tap_enclave_id_t,
  _cpu_addr_valid : addr_valid_t,
  _cpu_addr_map : addr_map_t,
  _cpu_owner_map : owner_map_t,
  _cache_valid_map : cache_valid_map_t,
  _cache_tag_map : cache_tag_map_t,
  _untrusted_addr_valid : addr_valid_t,
  _untrusted_addr_map : addr_map_t,
  _untrusted_regs : regs_t,
  _untrusted_pc : vaddr_t,
  _tap_enclave_metadata_valid : tap_enclave_metadata_valid_t,
  _tap_enclave_metadata_addr_map : tap_enclave_metadata_addr_map_t,
  _tap_enclave_metadata_addr_valid : tap_enclave_metadata_addr_valid_t,
  _tap_enclave_metadata_addr_excl : tap_enclave_metadata_addr_excl_t,
  _tap_enclave_metadata_entrypoint : tap_enclave_metadata_entrypoint_t,
  _tap_enclave_metadata_pc : tap_enclave_metadata_pc_t,
  _tap_enclave_metadata_regs : tap_enclave_metadata_regs_t,
  _tap_enclave_metadata_paused : tap_enclave_metadata_paused_t,
  _tap_enclave_metadata_cache_conflict : tap_enclave_metadata_cache_conflict_t
)
  modifies untrusted_addr_valid;
  modifies untrusted_addr_map;
  modifies untrusted_regs;
  modifies untrusted_pc;
  modifies tap_enclave_metadata_valid;
  modifies tap_enclave_metadata_addr_map;
  modifies tap_enclave_metadata_addr_valid;
  modifies tap_enclave_metadata_addr_excl;
  modifies tap_enclave_metadata_entrypoint;
  modifies tap_enclave_metadata_pc;
  modifies tap_enclave_metadata_regs;
  modifies tap_enclave_metadata_paused;
  modifies tap_enclave_metadata_cache_conflict;
  modifies cpu;
{
  untrusted_addr_valid                = _untrusted_addr_valid;
  untrusted_addr_map                  = _untrusted_addr_map;
  untrusted_regs                      = _untrusted_regs;
  untrusted_pc                        = _untrusted_pc;
  tap_enclave_metadata_valid          = _tap_enclave_metadata_valid;
  tap_enclave_metadata_addr_map       = _tap_enclave_metadata_addr_map;
  tap_enclave_metadata_addr_valid     = _tap_enclave_metadata_addr_valid;
  tap_enclave_metadata_addr_excl      = _tap_enclave_metadata_addr_excl;
  tap_enclave_metadata_entrypoint     = _tap_enclave_metadata_entrypoint;
  tap_enclave_metadata_pc             = _tap_enclave_metadata_pc;
  tap_enclave_metadata_regs           = _tap_enclave_metadata_regs;
  tap_enclave_metadata_paused         = _tap_enclave_metadata_paused;
  tap_enclave_metadata_cache_conflict = _tap_enclave_metadata_cache_conflict;
  call cpu.set_cpu_state(_cpu_enclave_id,
                         _cpu_addr_map,
                         _cpu_addr_valid,
                         _cpu_pc,
                         _cpu_regs);
  call cpu.set_cpu_owner_map(_cpu_owner_map);
  call cpu.set_cpu_mem(_cpu_mem);
  call cpu.set_cache(_cache_valid_map, _cache_tag_map);
}


init {
  //NOTE: No init state for this model
}

next {
  //NOTE: No stepping for this model
}


control {
  set_solver_option(":mbqi", false);
  set_solver_option(":case_split", 0);
  set_solver_option(":relevancy", 0);
  set_solver_option(":threads", 4);
  set_solver_option(":blast_full", true);

  //do_mappings_alias_verif = verify(do_mappings_alias_v);
  paddr_conflict_verif = verify(does_paddr_conflict);                     //passes
  enclave_conflict_verif = verify(does_enclave_conflict);                 //passes
  set_addr_map_verif = verify(set_addr_map);                              //no assertions to check
  get_enclave_addr_map_verif = verify(get_enclave_addr_map);              //no assertions to check
  set_enclave_addr_map_verif = verify(set_enclave_addr_map);              //no assertions to check
  tap_init_verif = verify(initialize_tap);                                //passes
  launch_verif = verify(launch);                                          //passes
  enter_verif  = verify(enter);                                           //passes
  resume_verif = verify(resume);                                          //passes
  exit_verif   = verify(exit);                                            //passes
  pause_verif  = verify(pause);                                           //passes
  destroy_verif = verify(destroy);                                        //passes
  block_memory_verif = verify(block_memory_region);                       //passes
  release_memory_verif = verify(release_blocked_memory);                  //passes
  tap_addr_valid_proofs_verif = verify(tap_addr_valid_proofs);            //passes
  init_havoc_verif = verify(InitialHavoc);                                //passes
  
  // shouldn't verify these since they are all inlined
  //untrusted_measurement_verif = verify(MeasurementUntrustedOp);           
  //enclave_measurement_verif = verify(MeasurementEnclaveOp);               
  //enclave_comp_verif = verify(EnclaveComputation);                        
  //integ_adv_step_verif = verify(IntegrityAdversarialStep);                
  //integ_enc_step_verif = verify(IntegrityEnclaveStep);                    
  //mem_obs_verif = verify(MemObserverComputation);                         
  //cache_obs_verif = verify(CacheObserverComputation);                     
  //pt_obs_verif = verify(PTObserverComputation);                           
  //obs_step_verif = verify(ObserverStep);                                  
  //enc_step_verif = verify(EnclaveStep);                                   


  
  check;
  print_results;
  //print_module;
  //launch_verif.print_cex(excl_vaddr, excl_paddr, addr_map, status);
}
  
  
}







      
